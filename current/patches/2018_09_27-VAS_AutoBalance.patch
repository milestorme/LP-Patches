From 5ee9d4e58e69aff180854263171d76fb831a1bbe Mon Sep 17 00:00:00 2001
From: LordPsyan <lordpsyan@gmail.com>
Date: Wed, 3 Oct 2018 04:26:53 -0500
Subject: [PATCH] 2018_09_27-VAS_AutoBalance

---
 VASAutoBalance.conf.dist                           | 200 ++++++++
 src/server/game/Entities/Creature/Creature.cpp     |   2 +
 src/server/game/Entities/Unit/Unit.cpp             |   6 +
 src/server/game/Scripting/ScriptMgr.cpp            |  65 +++
 src/server/game/Scripting/ScriptMgr.h              |  60 +++
 src/server/game/World/World.cpp                    |  19 +
 src/server/game/World/World.h                      |  22 +
 src/server/scripts/Custom/VAS_AutoBalance.cpp      | 515 +++++++++++++++++++++
 src/server/scripts/Custom/custom_script_loader.cpp |   6 +-
 src/server/worldserver/worldserver.conf.dist       |  72 +++
 10 files changed, 965 insertions(+), 2 deletions(-)
 create mode 100644 VASAutoBalance.conf.dist
 create mode 100644 src/server/scripts/Custom/VAS_AutoBalance.cpp

diff --git a/VASAutoBalance.conf.dist b/VASAutoBalance.conf.dist
new file mode 100644
index 0000000000..7e94af5f7d
--- /dev/null
+++ b/VASAutoBalance.conf.dist
@@ -0,0 +1,200 @@
+[worldserver]
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+# VAS AUTOBALANCE OPTIONS
+#
+#     VASAutoBalance.enable
+#        Enable/Disable Autobalance system
+#        Default:     1 (1 = ON, 0 = OFF)
+
+VASAutoBalance.enable=1
+
+#     VASAutoBalance.InflectionPoint
+#        Adjust value of Hyperbolic Tangent function where
+#        the curve of scaling must change. An higher value means higher difficulty.
+#
+#        Example: with 0.5, a creature of raid (40) will have half of its life with 20 players in
+#                 with 0.3, the same creature will have half of its life with 12 players in
+#
+#        Default:     0.5
+
+VASAutoBalance.InflectionPoint=0.5
+
+#     VASAutoBalance.numPlayer
+#        Set Server to level of solo mode.
+#        Set to 0 to Disable VAS-SOLO Mod.
+#        Example: VAS.AutoBalance.XPlayer = 1 will set everything for a 1 player game.
+#        Default:     1
+
+VASAutoBalance.numPlayer=1.0
+
+#
+#     VASAutoBalance.levelScaling
+#        Check the max level of players in map and scale creature based on it
+#        0 = Disabled
+#        1 = Enabled only in dungeons
+#        2 = Always enabled
+#        Default:     1
+
+VASAutoBalance.levelScaling=1
+
+#
+#     VASAutoBalance.levelHigherOffset
+#     VASAutoBalance.levelLowerOffset
+#        Level Offsets between creatures will not be scaled by level.
+#        You can even use it to disable scaling from lower to higher levelScaling
+#        setting levelLowerOffset to 80 (max wotlk level) for example.
+#        default: 3 (higher), 0 (lower) 
+
+VASAutoBalance.levelHigherOffset = 3
+VASAutoBalance.levelLowerOffset  = 0
+
+#
+#     VASAutoBalance.levelUseDbValuesWhenExists
+#        When enabled with levelScaling, the creature will use its default database values
+#        instead of level scaling formula when player/party level has correspondance with 
+#        creature_template minlevel/maxlevel.
+#
+#        Default:     0 (1 = ON, 0 = OFF)
+
+VASAutoBalance.levelUseDbValuesWhenExists = 0
+
+#
+#     VASAutoBalance.LevelEndGameBoost
+#        End game creatures have an exponential (not linear) regression
+#        that is not correctly handled by db values. Keep this enabled
+#        to have stats as near possible to the official ones.
+#
+#        Default:     1 (1 = ON, 0 = OFF)
+
+VASAutoBalance.LevelEndGameBoost = 1
+
+#
+#     VASAutoBalance.Instances
+#        Set instances to Auto chance XPlayer depending on players in it.
+#        Default:     1 (1 = ON, 0 = OFF)
+
+VASAutoBalance.Instances=1
+#
+#     VASAutoBalance.DungeonsOnly
+#        Only apply scaling changes to dungeons and raids
+#        Default:     1 (1 = ON, 0 = OFF)
+VASAutoBalance.DungeonsOnly=1
+
+#
+#     VASAutoBalance.DebugLevel
+#        0 = None
+#        1 = Errors Only
+#        2 = Errors and Basic Information
+#        3 = All VAS Info
+#        Default:     2
+
+VASAutoBalance.DebugLevel=2
+
+#
+#     VAS.AutoBalance.PlayerChangeNotify
+#        Set Auto Notifications to all players in Instance that player count has changed.
+#        Default:     1 (1 = ON, 0 = OFF)
+
+VASAutoBalance.PlayerChangeNotify=1
+
+#
+#     VASAutoBalance.MinHPModifier
+#        Minimum Modifier setting for Health Modification
+#        Default:     0.01
+
+VASAutoBalance.MinHPModifier=0.01
+
+#
+#     VASAutoBalance.MinDamageModifier
+#        Minimum Modifier setting for Damage Modification
+#        Default:     0.01
+
+VASAutoBalance.MinDamageModifier=0.01
+
+
+#
+#     VASAutoBalance.rate.*
+#        You can tune all rates increasing/decreasing difficulty in a linear way
+#        Note that global rate will increase all other rates. For example:
+#        global = 2.0 , damage = 1.5  -> it means that damage will be 3.0
+#        Default:     1.0
+
+VASAutoBalance.rate.global = 1.0
+VASAutoBalance.rate.health = 1.0
+VASAutoBalance.rate.mana   = 1.0
+VASAutoBalance.rate.armor  = 1.0
+VASAutoBalance.rate.damage = 1.0
+
+#
+#     VASAutoBalance.playerCountDifficultyOffset
+#        Offset of players inside an instance
+#        Default:     0
+
+VASAutoBalance.playerCountDifficultyOffset=0
+
+#
+#     VASAutoBalance.ForcedIDXX
+#        Sets MobIDs for the group they belong to.
+#        All 5 Man Mobs should go in VAS.AutoBalance.5.Name
+#        All 10 Man Mobs should go in VAS.AutoBalance.10.Name etc.
+
+VASAutoBalance.ForcedID40="11583,16441,30057,13020,15589,14435,18192,14889,14888,14887,14890,15302,15818,15742,15741,15740,18338"
+VASAutoBalance.ForcedID25="22997,21966,21965,21964,21806,21215,21845,19728,12397,17711,18256,18192,"
+VASAutoBalance.ForcedID20=""
+VASAutoBalance.ForcedID10="15689,15550,16152,17521,17225,16028,29324,31099"
+VASAutoBalance.ForcedID5="8317,15203,15204,15205,15305,6109,26801,30508,26799,30495,26803,30497,27859,27249"
+VASAutoBalance.ForcedID2=""
+
+#
+#     VASAutoBalance.DisableID
+#        Disable scaling on specific creatures
+#
+
+VASAutoBalance.DisableID=""
+
+##########################
+#
+# REWARD SYSTEM (experimental)
+#
+##########################
+
+
+#
+#   VASAutoBalance.reward.enable
+#       This is an experimental feature to reward a player that kill a boss when
+#       a pre-wotlk dungeon/raid is completed with creature levelling enabled.
+#       This is an idea to boost old contents even if you're end-game player.
+#
+#       Default:     0 (1 = ON, 0 = OFF)
+
+VASAutoBalance.reward.enable = 0
+
+
+#
+#   VASAutoBalance.reward.raidToken
+#   VASAutoBalance.reward.dungeonToken
+#
+#
+#       Default: 
+#           raidToken -> emblem of frost (49426)
+#           dungeonToken -> emblem of triumph (47241)
+
+VASAutoBalance.reward.raidToken    = 49426
+VASAutoBalance.reward.dungeonToken = 47241
+
+#
+#   VASAutoBalance.reward.MinPlayerReward
+#       This conf option checks how many players are in the same 
+#       map before allowing the reward to be carried out
+#       if MinPlayerReward is set to two and player is soloing this conf doesn't reward then.
+#		this will give more a challenge to players for low level instances.
+#
+#       Default:     1
+
+VASAutoBalance.reward.MinPlayerReward = 1
+#
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index 7cbb2e3d2b..e735fbb052 100644
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -1447,6 +1447,8 @@ void Creature::UpdateLevelDependantStats()
 
     float armor = (float)stats->GenerateArmor(cInfo); /// @todo Why is this treated as uint32 when it's a float?
     SetStatFlatModifier(UNIT_MOD_ARMOR, BASE_VALUE, armor);
+
+    sScriptMgr->Creature_SelectLevel(cInfo, this);
 }
 
 float Creature::_GetHealthMod(int32 Rank)
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 45a9d4b35d..9d6d9c672c 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -1415,6 +1415,7 @@ void Unit::DealMeleeDamage(CalcDamageInfo* damageInfo, bool durabilityLoss)
         if (victim->getLevel() < 30)
             chance = 0.65f * victim->getLevel() + 0.5f;
 
+
         uint32 const victimDefense = victim->GetDefenseSkillValue();
         uint32 const attackerMeleeSkill = GetMaxSkillValueForLevel();
 
@@ -2144,6 +2145,7 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackTy
     if (victim->GetTypeId() == TYPEID_PLAYER && crit_chance > 0 && !victim->IsStandState())
         return MELEE_HIT_CRIT;
 
+
     // 2. DODGE
     if (canDodge)
     {
@@ -3164,6 +3166,7 @@ void Unit::ProcessTerrainStatusUpdate(ZLiquidStatus status, Optional<LiquidData>
     else
         RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_UNDERWATER);
 
+
     // liquid aura handling
     LiquidTypeEntry const* curLiquid = nullptr;
     if ((status & MAP_LIQUID_STATUS_SWIMMING) && liquidData)
@@ -6344,7 +6347,10 @@ void Unit::SendHealSpellLog(HealInfo& healInfo, bool critical /*= false*/)
 int32 Unit::HealBySpell(HealInfo& healInfo, bool critical /*= false*/)
 {
     // calculate heal absorb and reduce healing
+    Unit* victim = healInfo.GetTarget();
+    uint32 addhealth = healInfo.GetHeal();
     Unit::CalcHealAbsorb(healInfo);
+    sScriptMgr->ModifyHealRecieved(this, victim, addhealth);
     Unit::DealHeal(healInfo);
     SendHealSpellLog(healInfo, critical);
     return healInfo.GetEffectiveHeal();
diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
index d63eca9242..4967e86705 100644
--- a/src/server/game/Scripting/ScriptMgr.cpp
+++ b/src/server/game/Scripting/ScriptMgr.cpp
@@ -44,6 +44,7 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+
 // Trait which indicates whether this script type
 // must be assigned in the database.
 template<typename>
@@ -791,6 +792,7 @@ public:
                 }
             }
 
+
             // If the script isn't assigned -> assign it!
             _scripts.insert(std::make_pair(id, std::move(script_ptr)));
             _ids_of_contexts.insert(std::make_pair(sScriptMgr->GetCurrentScriptContext(), id));
@@ -1365,6 +1367,44 @@ void ScriptMgr::OnGroupRateCalculation(float& rate, uint32 count, bool isRaid)
     FOREACH_SCRIPT(FormulaScript)->OnGroupRateCalculation(rate, count, isRaid);
 }
 
+void ScriptMgr::Creature_SelectLevel(const CreatureTemplate *cinfo, Creature* creature)
+{
+    FOREACH_SCRIPT(AllCreatureScript)->Creature_SelectLevel(cinfo, creature);
+}
+
+void ScriptMgr::SetInitialWorldSettings()
+{
+    FOREACH_SCRIPT(WorldScript)->SetInitialWorldSettings();
+}
+
+float ScriptMgr::VAS_Script_Hooks()
+{
+    float VAS_Script_Hook_Version = 1.03f;
+
+//    TC_LOG_DEBUG(LOG_FILTER_WORLDSERVER, "------------------------------------------------------------");
+//    TC_LOG_DEBUG(LOG_FILTER_WORLDSERVER, "  Powered by {VAS} Script Hooks v%4.2f : Updated by Natfoth",VAS_Script_Hook_Version);
+//    TC_LOG_DEBUG(LOG_FILTER_WORLDSERVER, "--------------------------------------------------------------");
+
+    return VAS_Script_Hook_Version;
+}
+
+void ScriptMgr::ModifyHealRecieved(Unit* target, Unit* attacker, uint32& damage)
+{
+    FOREACH_SCRIPT(UnitScript)->ModifyHealRecieved(target, attacker, damage);
+}
+
+AllMapScript::AllMapScript(const char* name)
+    : ScriptObject(name)
+{
+    ScriptRegistry<AllMapScript>::Instance()->AddScript(this);
+}
+
+AllCreatureScript::AllCreatureScript(const char* name)
+: ScriptObject(name)
+{
+    ScriptRegistry<AllCreatureScript>::Instance()->AddScript(this);
+}
+
 #define SCR_MAP_BGN(M, V, I, E, C, T) \
     if (V->GetEntry() && V->GetEntry()->T()) \
     { \
@@ -1457,6 +1497,8 @@ void ScriptMgr::OnPlayerEnterMap(Map* map, Player* player)
     ASSERT(map);
     ASSERT(player);
 
+    FOREACH_SCRIPT(AllMapScript)->OnPlayerEnterAll(map, player);
+
     FOREACH_SCRIPT(PlayerScript)->OnMapChanged(player);
 
     SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);
@@ -1477,6 +1519,8 @@ void ScriptMgr::OnPlayerLeaveMap(Map* map, Player* player)
     ASSERT(map);
     ASSERT(player);
 
+    FOREACH_SCRIPT(AllMapScript)->OnPlayerLeaveAll(map, player);
+
     SCR_MAP_BGN(WorldMapScript, map, itr, end, entry, IsWorldMap);
         itr->second->OnPlayerLeave(map, player);
     SCR_MAP_END;
@@ -1566,7 +1610,18 @@ bool ScriptMgr::OnCastItemCombatSpell(Player* player, Unit* victim, SpellInfo co
     GET_SCRIPT_RET(ItemScript, item->GetScriptId(), tmpscript, true);
     return tmpscript->OnCastItemCombatSpell(player, victim, spellInfo, item);
 }
+/* Needs Fixed
+void ScriptMgr::OnCreatureUpdate(Creature* creature, uint32 diff)
+{
+    ASSERT(creature);
+
+
+    FOREACH_SCRIPT(AllCreatureScript)->OnAllCreatureUpdate(creature, diff);
 
+    GET_SCRIPT(CreatureScript, creature->GetScriptId(), tmpscript);
+    tmpscript->OnUpdate(creature, diff);
+}
+*/
 CreatureAI* ScriptMgr::GetCreatureAI(Creature* creature)
 {
     ASSERT(creature);
@@ -1805,6 +1860,14 @@ bool ScriptMgr::OnCriteriaCheck(uint32 scriptId, Player* source, Unit* target)
     return tmpscript->OnCheck(source, target);
 }
 
+//Called From Unit::DealDamage
+uint32 ScriptMgr::DealDamage(Unit* AttackerUnit, Unit *pVictim, uint32 damage, DamageEffectType damagetype)
+{
+    FOR_SCRIPTS_RET(UnitScript, itr, end, damage)
+        damage = itr->second->DealDamage(AttackerUnit, pVictim, damage, damagetype);
+    return damage;
+}
+
 // Player
 void ScriptMgr::OnPVPKill(Player* killer, Player* killed)
 {
@@ -2306,10 +2369,12 @@ template class TC_GAME_API ScriptRegistry<SpellScriptLoader>;
 template class TC_GAME_API ScriptRegistry<ServerScript>;
 template class TC_GAME_API ScriptRegistry<WorldScript>;
 template class TC_GAME_API ScriptRegistry<FormulaScript>;
+template class TC_GAME_API ScriptRegistry<AllMapScript>;
 template class TC_GAME_API ScriptRegistry<WorldMapScript>;
 template class TC_GAME_API ScriptRegistry<InstanceMapScript>;
 template class TC_GAME_API ScriptRegistry<BattlegroundMapScript>;
 template class TC_GAME_API ScriptRegistry<ItemScript>;
+template class TC_GAME_API ScriptRegistry<AllCreatureScript>;
 template class TC_GAME_API ScriptRegistry<CreatureScript>;
 template class TC_GAME_API ScriptRegistry<GameObjectScript>;
 template class TC_GAME_API ScriptRegistry<AreaTriggerScript>;
diff --git a/src/server/game/Scripting/ScriptMgr.h b/src/server/game/Scripting/ScriptMgr.h
index 39a51c3be6..2e25a685fc 100644
--- a/src/server/game/Scripting/ScriptMgr.h
+++ b/src/server/game/Scripting/ScriptMgr.h
@@ -21,6 +21,7 @@
 
 #include "Common.h"
 #include "ObjectGuid.h"
+#include "Unit.h"
 #include <vector>
 
 class AccountMgr;
@@ -64,6 +65,7 @@ class WorldSession;
 struct AchievementCriteriaData;
 struct AreaTriggerEntry;
 struct AuctionEntry;
+struct CreatureTemplate;
 struct ConditionSourceInfo;
 struct Condition;
 struct CreatureTemplate;
@@ -271,6 +273,9 @@ class TC_GAME_API WorldScript : public ScriptObject
 
         // Called when the world is actually shut down.
         virtual void OnShutdown() { }
+
+        // Called at End of SetInitialWorldSettings.
+        virtual void SetInitialWorldSettings() { }
 };
 
 class TC_GAME_API FormulaScript : public ScriptObject
@@ -303,6 +308,21 @@ class TC_GAME_API FormulaScript : public ScriptObject
         virtual void OnGroupRateCalculation(float& /*rate*/, uint32 /*count*/, bool /*isRaid*/) { }
 };
 
+class AllMapScript : public ScriptObject
+{
+    protected:
+
+        AllMapScript(const char* name);
+
+    public:
+
+        // Called when a player enters any Map
+        virtual void OnPlayerEnterAll(Map* /*map*/, Player* /*player*/) { }
+
+        // Called when a player leave any Map
+        virtual void OnPlayerLeaveAll(Map* /*map*/, Player* /*player*/) { }
+};
+
 template<class TMap> class MapScript : public UpdatableScript<TMap>
 {
     MapEntry const* _mapEntry;
@@ -407,6 +427,13 @@ class TC_GAME_API UnitScript : public ScriptObject
 
         // Called when Spell Damage is being Dealt
         virtual void ModifySpellDamageTaken(Unit* /*target*/, Unit* /*attacker*/, int32& /*damage*/) { }
+
+        // Called when Heal is Recieved
+        virtual void ModifyHealRecieved(Unit* /*target*/, Unit* /*attacker*/, uint32& /*damage*/) { }
+
+        //VAS AutoBalance
+        virtual uint32 DealDamage(Unit* AttackerUnit, Unit *pVictim, uint32 damage, DamageEffectType damagetype) { return damage;}
+
 };
 
 class TC_GAME_API CreatureScript : public UnitScript
@@ -421,6 +448,21 @@ class TC_GAME_API CreatureScript : public UnitScript
         virtual CreatureAI* GetAI(Creature* /*creature*/) const = 0;
 };
 
+class TC_GAME_API AllCreatureScript : public ScriptObject
+{
+    protected:
+
+        AllCreatureScript(const char* name);
+
+    public:
+
+        // Called from End of Creature Update.
+        virtual void OnAllCreatureUpdate(Creature* /*creature*/, uint32 /*diff*/) { }
+
+        // Called from End of Creature SelectLevel.
+        virtual void Creature_SelectLevel(const CreatureTemplate* /*cinfo*/, Creature* /*creature*/) { }
+};
+
 class TC_GAME_API GameObjectScript : public ScriptObject
 {
     protected:
@@ -857,6 +899,10 @@ class TC_GAME_API ScriptMgr
 
         void Unload();
 
+    public: /* {VAS} Script Hooks */
+
+        float VAS_Script_Hooks();
+
     public: /* SpellScriptLoader */
 
         void CreateSpellScripts(uint32 spellId, std::vector<SpellScript*>& scriptVector, Spell* invoker) const;
@@ -882,6 +928,7 @@ class TC_GAME_API ScriptMgr
         void OnWorldUpdate(uint32 diff);
         void OnStartup();
         void OnShutdown();
+        void SetInitialWorldSettings();
 
     public: /* FormulaScript */
 
@@ -893,6 +940,11 @@ class TC_GAME_API ScriptMgr
         void OnGainCalculation(uint32& gain, Player* player, Unit* unit);
         void OnGroupRateCalculation(float& rate, uint32 count, bool isRaid);
 
+    public: /* AllScript */
+
+        void OnPlayerEnterMapAll(Map* map, Player* player);
+        void OnPlayerLeaveMapAll(Map* map, Player* player);
+
     public: /* MapScript */
 
         void OnCreateMap(Map* map);
@@ -915,6 +967,12 @@ class TC_GAME_API ScriptMgr
         bool OnItemRemove(Player* player, Item* item);
         bool OnCastItemCombatSpell(Player* player, Unit* victim, SpellInfo const* spellInfo, Item* item);
 
+    public: /* AllCreatureScript */
+
+        void OnAllCreatureUpdate(Creature* creature, uint32 diff);
+        void Creature_SelectLevel(const CreatureTemplate *cinfo, Creature* creature);
+
+
     public: /* CreatureScript */
 
         CreatureAI* GetCreatureAI(Creature* creature);
@@ -1053,6 +1111,8 @@ class TC_GAME_API ScriptMgr
         void ModifyPeriodicDamageAurasTick(Unit* target, Unit* attacker, uint32& damage);
         void ModifyMeleeDamage(Unit* target, Unit* attacker, uint32& damage);
         void ModifySpellDamageTaken(Unit* target, Unit* attacker, int32& damage);
+        void ModifyHealRecieved(Unit* target, Unit* attacker, uint32& addHealth);
+        uint32 DealDamage(Unit* AttackerUnit, Unit *pVictim,uint32 damage,DamageEffectType damagetype);
 
     private:
         uint32 _scriptCount;
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index 82dbe507d3..dd8884e8d3 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -1471,6 +1471,22 @@ void World::LoadConfigSettings(bool reload)
     m_bool_configs[CONFIG_PDUMP_NO_OVERWRITE] = sConfigMgr->GetBoolDefault("PlayerDump.DisallowOverwrite", true);
     m_bool_configs[CONFIG_UI_QUESTLEVELS_IN_DIALOGS] = sConfigMgr->GetBoolDefault("UI.ShowQuestLevelsInDialogs", false);
 
+    //VAS
+    m_int_configs[VAS_VasDebug] = sConfigMgr->GetIntDefault ("VAS.AutoBalance.Debug", 1);
+    m_int_configs[VAS_AutoInstance] = sConfigMgr->GetIntDefault ("VAS.AutoBalance.AutoInstance", 1);
+    m_int_configs[VAS_PlayerChangeNotify] = sConfigMgr->GetIntDefault ("VAS.AutoBalance.PlayerChangeNotify", 1);
+
+    m_float_configs[VAS_Config_xPlayer] = sConfigMgr->GetFloatDefault("VAS.AutoBalance.XPlayer", 1.0f);
+    m_float_configs[VAS_Min_D_Mod] = sConfigMgr->GetFloatDefault("Min.D.Mod", 0.10f);
+    m_float_configs[VAS_Min_HP_Mod] = sConfigMgr->GetFloatDefault("Min.HP.Mod", 0.20f);
+
+    std::string VAS_AutoBalance_40_Name = sConfigMgr->GetStringDefault("VAS.AutoBalance.40.Name", "");
+    std::string VAS_AutoBalance_25_Name = sConfigMgr->GetStringDefault("VAS.AutoBalance.25.Name", "");
+    std::string VAS_AutoBalance_20_Name = sConfigMgr->GetStringDefault("VAS.AutoBalance.20.Name", "");
+    std::string VAS_AutoBalance_10_Name = sConfigMgr->GetStringDefault("VAS.AutoBalance.10.Name", "");
+    std::string VAS_AutoBalance_5_Name = sConfigMgr->GetStringDefault("VAS.AutoBalance.5.Name", "");
+    std::string VAS_AutoBalance_2_Name = sConfigMgr->GetStringDefault("VAS.AutoBalance.2.Name", "");
+
     // Wintergrasp battlefield
     m_bool_configs[CONFIG_WINTERGRASP_ENABLE] = sConfigMgr->GetBoolDefault("Wintergrasp.Enable", false);
     m_int_configs[CONFIG_WINTERGRASP_PLR_MAX] = sConfigMgr->GetIntDefault("Wintergrasp.PlayerMax", 100);
@@ -2142,6 +2158,9 @@ void World::SetInitialWorldSettings()
     // Delete all characters which have been deleted X days before
     Player::DeleteOldCharacters();
 
+    TC_LOG_INFO("server.loading", "Loading VAS Autobalance...");
+    sScriptMgr->SetInitialWorldSettings();
+
     TC_LOG_INFO("server.loading", "Initialize AuctionHouseBot...");
     sAuctionBot->Initialize();
 
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index c0cb58fc77..108aeb770c 100644
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -238,6 +238,9 @@ enum WorldFloatConfigs
     CONFIG_CREATURE_FAMILY_ASSISTANCE_RADIUS,
     CONFIG_THREAT_RADIUS,
     CONFIG_CHANCE_OF_GM_SURVEY,
+    VAS_Config_xPlayer,
+    VAS_Min_D_Mod,
+    VAS_Min_HP_Mod,
     CONFIG_STATS_LIMITS_DODGE,
     CONFIG_STATS_LIMITS_PARRY,
     CONFIG_STATS_LIMITS_BLOCK,
@@ -441,6 +444,9 @@ enum WorldIntConfigs
     CONFIG_WARDEN_CLIENT_BAN_DURATION,
     CONFIG_WARDEN_NUM_MEM_CHECKS,
     CONFIG_WARDEN_NUM_OTHER_CHECKS,
+    VAS_VasDebug,
+    VAS_AutoInstance,
+    VAS_PlayerChangeNotify,
     CONFIG_WINTERGRASP_PLR_MAX,
     CONFIG_WINTERGRASP_PLR_MIN,
     CONFIG_WINTERGRASP_PLR_MIN_LVL,
@@ -768,6 +774,14 @@ class TC_GAME_API World
         /// Get the path where data (dbc, maps) are stored on disk
         std::string const& GetDataPath() const { return m_dataPath; }
 
+        /// Return the Mob IDs to be Autobalanced
+        std::string GetVAS40() const { return VAS_AutoBalance_40_Name; }
+        std::string GetVAS25() const { return VAS_AutoBalance_25_Name; }
+        std::string GetVAS20() const { return VAS_AutoBalance_20_Name; }
+        std::string GetVAS10() const { return VAS_AutoBalance_10_Name; }
+        std::string GetVAS5() const { return VAS_AutoBalance_5_Name; }
+        std::string GetVAS2() const { return VAS_AutoBalance_2_Name; }
+
         /// Next daily quests and random bg reset time
         time_t GetNextDailyQuestsResetTime() const { return m_NextDailyQuestReset; }
         time_t GetNextWeeklyQuestsResetTime() const { return m_NextWeeklyQuestReset; }
@@ -928,6 +942,14 @@ class TC_GAME_API World
         uint32 m_ShutdownTimer;
         uint32 m_ShutdownMask;
 
+        std::string VAS_AutoBalance_40_Name;
+        std::string VAS_AutoBalance_25_Name;
+        std::string VAS_AutoBalance_20_Name;
+        std::string VAS_AutoBalance_10_Name;
+        std::string VAS_AutoBalance_5_Name;
+        std::string VAS_AutoBalance_2_Name;
+        std::string VAS_color;
+
         uint32 m_CleaningFlags;
 
         bool m_isClosed;
diff --git a/src/server/scripts/Custom/VAS_AutoBalance.cpp b/src/server/scripts/Custom/VAS_AutoBalance.cpp
new file mode 100644
index 0000000000..eb5c6cb359
--- /dev/null
+++ b/src/server/scripts/Custom/VAS_AutoBalance.cpp
@@ -0,0 +1,515 @@
+/*
+ * Copyright (C) 2012 CVMagic <http://www.trinitycore.org/f/topic/6551-vas-autobalance/>
+ * Copyright (C) 2008-2010 TrinityCore <http://www.trinitycore.org/>
+ * Copyright (C) 2006-2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * Copyright (C) 1985-2010 {VAS} KalCorp  <http://vasserver.dyndns.org/>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+ * Script Name: AutoBalance
+ * Original Authors: KalCorp and Vaughner
+ * Maintainer(s): CVMagic
+ * Original Script Name: VAS.AutoBalance
+ * Description: This script is intended to scale based on number of players, instance mobs & world bosses' health, mana, and damage.
+ */
+
+
+//#include "ScriptPCH.h"
+#include "Configuration/Config.h"
+#include "Unit.h"
+#include "Chat.h"
+#include "Creature.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "MapManager.h"
+#include "World.h"
+#include "Map.h"
+#include "ScriptMgr.h"
+#include <vector>
+
+#define BOOL_TO_STRING(b) ((b)? "true":"false")
+
+struct AutoBalanceCreatureInfo
+{
+    uint32 instancePlayerCount;
+    float DamageMultiplier;
+};
+
+static std::map<uint32, AutoBalanceCreatureInfo> CreatureInfo; // A hook should be added to remove the mapped entry when the creature is dead or this should be added into the creature object
+static std::map<int, int> forcedCreatureIds;                   // The map values correspond with the VAS.AutoBalance.XX.Name entries in the configuration file.
+
+int GetValidDebugLevel()
+{
+    int debugLevel = sWorld->getIntConfig(VAS_VasDebug);
+
+    if ((debugLevel < 0) || (debugLevel > 3))
+    {
+        return 1;
+    }
+    return debugLevel;
+}
+
+void LoadForcedCreatureIdsFromString(std::string creatureIds, int forcedPlayerCount) // Used for reading the string from the configuration file to for those creatures who need to be scaled for XX number of players.
+{
+    std::string delimitedValue;
+    std::stringstream creatureIdsStream;
+
+    creatureIdsStream.str(creatureIds);
+    while (std::getline(creatureIdsStream, delimitedValue, ',')) // Process each Creature ID in the string, delimited by the comma - ","
+    {
+        int creatureId = atoi(delimitedValue.c_str());
+        if (creatureId >= 0)
+        {
+            forcedCreatureIds[creatureId] = forcedPlayerCount;
+        }
+    }
+}
+
+int GetForcedCreatureId(int creatureId)
+{
+    if(forcedCreatureIds.find(creatureId) == forcedCreatureIds.end()) // Don't want the forcedCreatureIds map to blowup to a massive empty array
+    {
+        return 0;
+    }
+    return forcedCreatureIds[creatureId];
+}
+
+class VAS_AutoBalance_WorldScript : public WorldScript
+{
+    public:
+        VAS_AutoBalance_WorldScript()
+            : WorldScript("VAS_AutoBalance_WorldScript")
+        {
+        }
+
+    void OnConfigLoad(bool /*reload*/)
+    {
+    }
+
+    void OnStartup()
+    {
+    }
+
+    void SetInitialWorldSettings()
+    {
+        // Load from the VAS.AutoBalance.XX.Name entries in the Configuration File
+        forcedCreatureIds.clear();
+        LoadForcedCreatureIdsFromString(sWorld->GetVAS40(), 40);
+        LoadForcedCreatureIdsFromString(sWorld->GetVAS25(), 25);
+        LoadForcedCreatureIdsFromString(sWorld->GetVAS10(), 10);
+        LoadForcedCreatureIdsFromString(sWorld->GetVAS5(), 5);
+        LoadForcedCreatureIdsFromString(sWorld->GetVAS2(), 2);
+
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "----------------------------------------------------");
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "  Powered by {VAS} AutoBalance");
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "----------------------------------------------------");
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "  xPlayer = %4.1f ", sWorld->getFloatConfig(VAS_Config_xPlayer));
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "  AutoInstance = %u ", sWorld->getIntConfig(VAS_AutoInstance));
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "  PlayerChangeNotify = %u ", sWorld->getIntConfig(VAS_PlayerChangeNotify));
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "  Min.D.Mod = %4.2f ", sWorld->getFloatConfig(VAS_Min_D_Mod));
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "  Min.HP.Mod = %4.2f ", sWorld->getFloatConfig(VAS_Min_HP_Mod));
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "  VasDebug   =  %u ", GetValidDebugLevel());
+        //sLog->outInfo(LOG_FILTER_WORLDSERVER, "----------------------------------------------------\n");
+    }
+
+
+};
+
+class VAS_AutoBalance_PlayerScript : public PlayerScript
+{
+    public:
+        VAS_AutoBalance_PlayerScript()
+            : PlayerScript("VAS_AutoBalance_PlayerScript")
+        {
+        }
+
+    void OnLogin(Player *Player, bool /*firstLogin*/)
+    {
+            //TC_LOG_INFO("vas.player.loading", "### VAS_AutoBalance_PlayerScript - OnLogin Player=%s", Player->GetName());
+    }
+};
+
+class VAS_AutoBalance_UnitScript : public UnitScript
+{
+    public:
+        VAS_AutoBalance_UnitScript()
+            : UnitScript("VAS_AutoBalance_UnitScript")
+        {
+        }
+
+    uint32 DealDamage(Unit* AttackerUnit, Unit *playerVictim, uint32 damage, DamageEffectType damagetype)
+    {
+        if (AttackerUnit->GetMap()->IsDungeon() && playerVictim->GetMap()->IsDungeon())
+            if (AttackerUnit->GetTypeId() != TYPEID_PLAYER)
+            {
+                //if (GetValidDebugLevel() >= 3)
+                    //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_UnitScript - VAS_Unit_DealDamage Attacker=%s Victim=%s Start Damage=%u",AttackerUnit->GetName(),playerVictim->GetName(),damage);
+                damage = VAS_Modifer_DealDamage(AttackerUnit,damage);
+                //if (GetValidDebugLevel() >= 3)
+                    //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_UnitScript - VAS_Unit_DealDamage Attacker=%s Victim=%s End Damage=%u",AttackerUnit->GetName(),playerVictim->GetName(),damage);
+            }
+            return damage;
+    }
+
+    uint32 HandlePeriodicDamageAurasTick(Unit *target, Unit *caster, int32 damage)
+    {
+        if (caster->GetMap()->IsDungeon() && target->GetMap()->IsDungeon())
+            if (caster->GetTypeId() != TYPEID_PLAYER)
+            {
+                //if (GetValidDebugLevel() >= 3)
+                    //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_UnitScript - VAS_Unit_HandlePeriodicDamage Attacker=%s Victim=%s Start Damage=%u",caster->GetName(),target->GetName(),damage);
+
+                if (!((caster->IsHunterPet() || caster->IsPet() || caster->IsSummon()) && caster->IsControlledByPlayer()))
+                    damage = (float)damage * (float)CreatureInfo[caster->GetGUID()].DamageMultiplier;
+
+                //if (GetValidDebugLevel() >= 3)
+                    //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_UnitScript - VAS_Unit_HandlePeriodicDamage Attacker=%s Victim=%s End Damage=%u",caster->GetName(),target->GetName(),damage);
+            }
+            return damage;
+    }
+
+    void CalculateSpellDamageTaken(SpellNonMeleeDamage *damageInfo, int32 damage, SpellInfo const *spellInfo, WeaponAttackType attackType, bool crit)
+    {
+        if ((damageInfo->attacker->GetMap()->IsDungeon() && damageInfo->target->GetMap()->IsDungeon()) || ( damageInfo->attacker->GetMap()->IsBattleground() && damageInfo->target->GetMap()->IsBattleground()))
+        {
+            if (damageInfo->attacker->GetTypeId() != TYPEID_PLAYER)
+            {
+                //if (GetValidDebugLevel() >= 3)
+                    //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_UnitScript - CalculateSpellDamageTaken Attacker=%s Victim=%s Start Damage=%u",damageInfo->attacker->GetName(),damageInfo->target->GetName(),damageInfo->damage);
+
+                if ((damageInfo->attacker->IsHunterPet() || damageInfo->attacker->IsPet() || damageInfo->attacker->IsSummon()) && damageInfo->attacker->IsControlledByPlayer())
+                    return;
+
+                damageInfo->damage = (float)damageInfo->damage * (float)CreatureInfo[damageInfo->attacker->GetGUID()].DamageMultiplier;
+
+                //if (GetValidDebugLevel() >= 3)
+                    //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_UnitScript - CalculateSpellDamageTaken Attacker=%s Victim=%s End Damage=%u",damageInfo->attacker->GetName(),damageInfo->target->GetName(),damageInfo->damage);
+            }
+        }
+            return;
+    }
+
+    void CalculateMeleeDamage(Unit *playerVictim, uint32 damage, CalcDamageInfo *damageInfo, WeaponAttackType attackType)
+    {
+        // Make sure the Attacker and the Victim are in the same location, in addition that the attacker is not player.
+        if (((damageInfo->Attacker->GetMap()->IsDungeon() && damageInfo->Target->GetMap()->IsDungeon()) || (damageInfo->Attacker->GetMap()->IsBattleground() && damageInfo->Target->GetMap()->IsBattleground())) && (damageInfo->Attacker->GetTypeId() != TYPEID_PLAYER))
+            if (!((damageInfo->Attacker->IsHunterPet() || damageInfo->Attacker->IsPet() || damageInfo->Attacker->IsSummon()) && damageInfo->Attacker->IsControlledByPlayer())) // Make sure that the attacker Is not a Pet of some sort
+            {
+                //if (GetValidDebugLevel() >= 3)
+                    //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_UnitScript - CalculateMeleeDamage Attacker=%s Victim=%s Start Damage=%u",damageInfo->attacker->GetName(),damageInfo->target->GetName(),damageInfo->damage);
+
+                damageInfo->Damages[0].Damage = (float)damageInfo->Damages[0].Damage * (float)CreatureInfo[damageInfo->Attacker->GetGUID()].DamageMultiplier;
+
+                //if (GetValidDebugLevel() >= 3)
+                    //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_UnitScript - CalculateMeleeDamage Attacker=%s Victim=%s End Damage=%u",damageInfo->attacker->GetName(),damageInfo->target->GetName(),damageInfo->damage);
+            }
+            return;
+    }
+
+    uint32 VAS_Modifer_DealDamage(Unit* AttackerUnit,uint32 damage)
+    {
+    if ((AttackerUnit->IsHunterPet() || AttackerUnit->IsPet() || AttackerUnit->IsSummon()) && AttackerUnit->IsControlledByPlayer())
+        return damage;
+
+    float damageMultiplier = CreatureInfo[AttackerUnit->GetGUID()].DamageMultiplier;
+
+    return damage * damageMultiplier;
+
+    }
+
+
+};
+
+
+class VAS_AutoBalance_AllMapScript : public AllMapScript
+{
+    public:
+        VAS_AutoBalance_AllMapScript()
+            : AllMapScript("VAS_AutoBalance_AllMapScript")
+        {
+        }
+
+    void OnPlayerEnterAll(Map* map, Player* player)
+    {
+        if (GetValidDebugLevel() >= 2)
+        {
+            //sLog->outInfo(LOG_FILTER_TSCR, "----------------------------------------------------");
+            //sLog->outInfo(LOG_FILTER_TSCR, "## VAS_AutoBalance_AllMapScript - OnPlayerEnterAll");
+            //sLog->outInfo(LOG_FILTER_TSCR, "## For InsatanceID %u",map->GetInstanceId());
+            //sLog->outInfo(LOG_FILTER_TSCR, "## IsDungeon= %u",map->GetEntry()->IsDungeon());
+            //sLog->outInfo(LOG_FILTER_TSCR, "## For Map %u",player->GetMapId());
+            //sLog->outInfo(LOG_FILTER_TSCR, "## PlayersInMap %u",map->GetPlayersCountExceptGMs());
+            //sLog->outInfo(LOG_FILTER_TSCR, "## pDifficulty %u",uint32(player->GetDifficulty(player->GetMap()->IsHeroic())));
+            //sLog->outInfo(LOG_FILTER_TSCR, "## pGetDungeonDifficulty %u",uint32(player->GetDungeonDifficulty()));
+            //sLog->outInfo(LOG_FILTER_TSCR, "## pGetRaidDifficulty %u",uint32(player->GetRaidDifficulty()));
+            //sLog->outInfo(LOG_FILTER_TSCR, "## maxPlayers %u",((InstanceMap*)sMapMgr->FindMap(player->GetMapId(), player->GetInstanceId()))->GetMaxPlayers());
+            //sLog->outInfo(LOG_FILTER_TSCR, "## IsHeroic=%s IsRaid=%s IsRegularDifficulty=%s IsRaidOrHeroicDungeon=%s IsNonRaidDungeon=%s",BOOL_TO_STRING(player->GetMap()->IsHeroic()),BOOL_TO_STRING(player->GetMap()->IsRaid()),BOOL_TO_STRING(player->GetMap()->IsRegularDifficulty()),BOOL_TO_STRING(player->GetMap()->IsRaidOrHeroicDungeon()),BOOL_TO_STRING(player->GetMap()->IsNonRaidDungeon()));
+            //sLog->outInfo(LOG_FILTER_TSCR, "----------------------------------------------------\n");
+        }
+
+        if (sWorld->getIntConfig(VAS_PlayerChangeNotify) >= 1)
+        {
+            if ((map->GetEntry()->IsDungeon()) && !player->IsGameMaster() )
+            {
+                Map::PlayerList const &playerList = map->GetPlayers();
+                if (!playerList.isEmpty())
+                {
+                    for (Map::PlayerList::const_iterator playerIteration = playerList.begin(); playerIteration != playerList.end(); ++playerIteration)
+                    {
+                        if (Player* playerHandle = playerIteration->GetSource())
+                        {
+                            ChatHandler chatHandle = ChatHandler(playerHandle->GetSession());
+                            chatHandle.PSendSysMessage("|cffFF0000 [AutoBalance]|r|cffFF8000 %s entered the Instance %s. Auto setting player count to %u |r",player->GetName().c_str(),map->GetMapName(),map->GetPlayersCountExceptGMs());
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    void OnPlayerLeaveAll(Map* map, Player* player)
+    {
+
+        //if (GetValidDebugLevel() >= 3)
+            //sLog->outInfo(LOG_FILTER_TSCR, "#### VAS_AutoBalance_AllMapScript - OnPlayerLeaveAll map=%s player=%s", map->GetMapName(),player->GetName());
+
+
+        int instancePlayerCount = map->GetPlayersCountExceptGMs() - 1;
+
+        if (instancePlayerCount >=1)
+        {
+            if (GetValidDebugLevel() >= 2)
+            {
+                //sLog->outInfo(LOG_FILTER_TSCR, "----------------------------------------------------");
+                //sLog->outInfo(LOG_FILTER_TSCR, "## VAS_AutoBalance_AllMapScript - OnPlayerLeaveAll");
+                //sLog->outInfo(LOG_FILTER_TSCR, "## For InsatanceID %u",map->GetInstanceId());
+                //sLog->outInfo(LOG_FILTER_TSCR, "## IsDungeon= %u",map->GetEntry()->IsDungeon());
+                //sLog->outInfo(LOG_FILTER_TSCR, "## For Map %u",player->GetMapId());
+                //sLog->outInfo(LOG_FILTER_TSCR, "## PlayersInMap %u",instancePlayerCount);
+                //sLog->outInfo(LOG_FILTER_TSCR, "----------------------------------------------------\n");
+            }
+
+            if (sWorld->getIntConfig(VAS_PlayerChangeNotify) >= 1)
+            {
+                if ((map->GetEntry()->IsDungeon()) && !player->IsGameMaster())
+                {
+                    Map::PlayerList const &playerList = map->GetPlayers();
+                    if (!playerList.isEmpty())
+                    {
+                        for (Map::PlayerList::const_iterator playerIteration = playerList.begin(); playerIteration != playerList.end(); ++playerIteration)
+                        {
+                            if (Player* playerHandle = playerIteration->GetSource())
+                            {
+                                ChatHandler chatHandle = ChatHandler(playerHandle->GetSession());
+                                chatHandle.PSendSysMessage("|cffFF0000 [VAS-AutoBalance]|r|cffFF8000 %s left the Instance %s. Auto setting player count to %u |r",player->GetName().c_str(),map->GetMapName(),instancePlayerCount);
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+};
+
+class VAS_AutoBalance_WorldMapScript : public WorldMapScript
+{
+    public:
+        VAS_AutoBalance_WorldMapScript()
+            : WorldMapScript("VAS_AutoBalance_WorldMapScript",0)
+        {
+        }
+
+    void OnPlayerEnter(Map* map, Player* player)
+    {
+
+        //if (GetValidDebugLevel() >= 3)
+            //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_WorldMapScript - OnPlayerEnter Map=%s player=%s",map->GetMapName(),player->GetName());
+    }
+
+    void OnPlayerLeave(Map* map, Player* player)
+    {
+
+        //if (GetValidDebugLevel() >= 3)
+            //sLog->outInfo(LOG_FILTER_TSCR, "### VAS_AutoBalance_WorldMapScript - OnPlayerLeave Map=%s player=%s",map->GetMapName(),player->GetName());
+    }
+};
+
+
+class VAS_AutoBalance_AllCreatureScript : public AllCreatureScript
+{
+    public:
+        VAS_AutoBalance_AllCreatureScript()
+            : AllCreatureScript("VAS_AutoBalance_AllCreatureScript")
+        {
+        }
+
+
+    void Creature_SelectLevel(const CreatureTemplate *creatureTemplate, Creature* creature)
+    {
+
+
+        if (creature->GetMap()->IsDungeon())
+        {
+            ModifyCreatureAttributes(creature);
+            CreatureInfo[creature->GetGUID()].instancePlayerCount = creature->GetMap()->GetPlayersCountExceptGMs();
+        }
+    }
+
+    void OnAllCreatureUpdate(Creature* creature, uint32 diff)
+    {
+        if(!(CreatureInfo[creature->GetGUID()].instancePlayerCount == creature->GetMap()->GetPlayersCountExceptGMs()))
+        {
+            if (creature->GetMap()->IsDungeon() || creature->GetMap()->IsBattleground())
+                ModifyCreatureAttributes(creature);
+            CreatureInfo[creature->GetGUID()].instancePlayerCount = creature->GetMap()->GetPlayersCountExceptGMs();
+        }
+    }
+
+    void ModifyCreatureAttributes(Creature* creature)
+    {
+        if(((creature->IsHunterPet() || creature->IsPet() || creature->IsSummon()) && creature->IsControlledByPlayer()) || sWorld->getIntConfig(VAS_AutoInstance) < 1 || creature->GetMap()->GetPlayersCountExceptGMs() <= 0)
+        {
+            return;
+        }
+
+        CreatureTemplate const *creatureTemplate = creature->GetCreatureTemplate();
+        CreatureBaseStats const* creatureStats = sObjectMgr->GetCreatureBaseStats(creature->getLevel(), creatureTemplate->unit_class);
+
+        float damageMultiplier = 1.0f;
+        float healthMultiplier = 1.0f;
+
+        uint32 baseHealth = creatureStats->GenerateHealth(creatureTemplate);
+        uint32 baseMana = creatureStats->GenerateMana(creatureTemplate);
+        uint32 instancePlayerCount = creature->GetMap()->GetPlayersCountExceptGMs();
+        uint32 maxNumberOfPlayers = ((InstanceMap*)sMapMgr->FindMap(creature->GetMapId(), creature->GetInstanceId()))->GetMaxPlayers();
+        uint32 scaledHealth = 0;
+        uint32 scaledMana = 0;
+
+        //   VAS SOLO  - By MobID
+        if(GetForcedCreatureId(creatureTemplate->Entry) > 0)
+        {
+            maxNumberOfPlayers = GetForcedCreatureId(creatureTemplate->Entry); // Force maxNumberOfPlayers to be changed to match the Configuration entry.
+        }
+
+        // (tanh((X-2.2)/1.5) +1 )/2    // 5 Man formula X = Number of Players
+        // (tanh((X-5)/2) +1 )/2        // 10 Man Formula X = Number of Players
+        // (tanh((X-16.5)/6.5) +1 )/2   // 25 Man Formula X = Number of players
+        //
+        // Note: The 2.2, 5, and 16.5 are the number of players required to get 50% health.
+        //       It's not required this be a whole number, you'd adjust this to raise or lower
+        //       the hp modifier for per additional player in a non-whole group. These
+        //       values will eventually be part of the configuration file once I finalize the mod.
+        //
+        //       The 1.5, 2, and 6.5 modify the rate of percentage increase between
+        //       number of players. Generally the closer to the value of 1 you have this
+        //       the less gradual the rate will be. For example in a 5 man it would take 3
+        //       total players to face a mob at full health.
+        //
+        //       The +1 and /2 values raise the TanH function to a positive range and make
+        //       sure the modifier never goes above the value or 1.0 or below 0.
+        //
+        //       Lastly this formula has one side effect on full groups Bosses and mobs will
+        //       never have full health, this can be tested against by making sure the number
+        //       of players match the maxNumberOfPlayers variable.
+
+        switch (maxNumberOfPlayers)
+        {
+        case 40:
+            healthMultiplier = (float)instancePlayerCount / (float)maxNumberOfPlayers; // 40 Man Instances oddly enough scale better with the old formula
+            break;
+        case 25:
+            healthMultiplier = (tanh((instancePlayerCount - 16.5f) / 1.5f) + 1.0f) / 2.0f;
+            break;
+        case 10:
+            healthMultiplier = (tanh((instancePlayerCount - 4.5f) / 1.5f) + 1.0f) / 2.0f;
+            break;
+        case 2:
+            healthMultiplier = (float)instancePlayerCount / (float)maxNumberOfPlayers;                   // Two Man Creatures are too easy if handled by the 5 man formula, this would only
+            break;                                                                         // apply in the situation where it's specified in the configuration file.
+        default:
+            healthMultiplier = (tanh((instancePlayerCount - 2.2f) / 1.5f) + 1.0f) / 2.0f;    // default to a 5 man group
+        }
+
+        //   VAS SOLO  - Map 0,1 and 530 ( World Mobs )                                                               // This may be where VAS_AutoBalance_CheckINIMaps might have come into play. None the less this is
+        if((creature->GetMapId() == 0 || creature->GetMapId() == 1 || creature->GetMapId() == 530) && (creature->isElite() || creature->isWorldBoss()))  // specific to World Bosses and elites in those Maps, this is going to use the entry XPlayer in place of instancePlayerCount.
+        {
+            if(baseHealth > 800000){
+                healthMultiplier = (tanh((sWorld->getFloatConfig(VAS_Config_xPlayer) - 5.0f) / 1.5f) + 1.0f) / 2.0f;
+            }else{
+                healthMultiplier = (tanh((sWorld->getFloatConfig(VAS_Config_xPlayer) - 2.2f) / 1.5f) + 1.0f) / 2.0f; // Assuming a 5 man configuration, as World Bosses have been relatively retired since BC so unless the boss has some substantial baseHealth
+            }
+
+        }
+
+        // Ensure that the healthMultiplier is not lower than the configuration specified value. -- This may be Deprecated later.
+        if(healthMultiplier <= sWorld->getFloatConfig(VAS_Min_HP_Mod) )
+        {
+            healthMultiplier = sWorld->getFloatConfig(VAS_Min_HP_Mod);
+        }
+
+        //Getting the list of Classes in this group - this will be used later on to determine what additional scaling will be required based on the ratio of tank/dps/healer
+        //GetPlayerClassList(creature, playerClassList); // Update playerClassList with the list of all the participating Classes
+
+
+        scaledHealth = uint32((baseHealth * healthMultiplier) + 1.0f);
+        // Now adjusting Mana, Mana is something that can be scaled linearly
+        if (maxNumberOfPlayers==0){
+            scaledMana = uint32((baseMana * healthMultiplier) + 1.0f);
+            // Now Adjusting Damage, this too is linear for now .... this will have to change I suspect.
+            damageMultiplier = healthMultiplier;
+        }else{
+            scaledMana = ((baseMana/maxNumberOfPlayers) * instancePlayerCount);
+            // Now Adjusting Damage, this too is linear for now .... this will have to change I suspect.
+            damageMultiplier = (float)instancePlayerCount / (float)maxNumberOfPlayers;
+        }
+
+        // Can not be less then Min_D_Mod
+        if(damageMultiplier <= sWorld->getFloatConfig(VAS_Min_D_Mod))
+        {
+            damageMultiplier = sWorld->getFloatConfig(VAS_Min_D_Mod);
+        }
+
+        if((GetValidDebugLevel() >= 3))
+        {
+            //sLog->outInfo(LOG_FILTER_TSCR, "## VAS-AutoBalance MobID=%u MapID=%u creatureName=%s  GUID=%llu  instancePlayerCount=%u", creatureTemplate->Entry, creature->GetMapId(), creatureTemplate->Name.c_str(), creature->GetGUID(), instancePlayerCount);
+            //sLog->outInfo(LOG_FILTER_TSCR, "## VAS-AutoBalance MapDifficulty=%u Health=%u / %u healthMultiplier=%4.5f", creature->GetMap()->GetDifficulty(), scaledHealth, baseHealth, healthMultiplier);
+            //sLog->outInfo(LOG_FILTER_TSCR, "## VAS-AutoBalance maxNumberOfPlayers=%u IsRaid=%s", maxNumberOfPlayers, BOOL_TO_STRING(creature->GetMap()->IsRaid()));
+            //sLog->outInfo(LOG_FILTER_TSCR, "## VAS-AutoBalance Mana %u / %u", baseMana, scaledMana);
+            //sLog->outInfo(LOG_FILTER_TSCR, "## VAS-AutoBalance damageMultiplier=%4.2f", damageMultiplier);
+        }
+
+        creature->SetCreateHealth(scaledHealth);
+        creature->SetMaxHealth(scaledHealth);
+        creature->ResetPlayerDamageReq();
+        creature->SetCreateMana(scaledMana);
+        creature->SetMaxPower(POWER_MANA, scaledMana);
+        creature->SetPower(POWER_MANA, scaledMana);
+        creature->SetStatFlatModifier(UNIT_MOD_HEALTH, BASE_VALUE, (float)scaledHealth);
+        creature->SetStatFlatModifier(UNIT_MOD_MANA, BASE_VALUE, (float)scaledMana);
+        CreatureInfo[creature->GetGUID()].DamageMultiplier = damageMultiplier;
+    }
+};
+
+
+void AddSC_VAS_AutoBalance()
+{
+    new VAS_AutoBalance_WorldScript;
+    new VAS_AutoBalance_PlayerScript;
+    new VAS_AutoBalance_UnitScript;
+    new VAS_AutoBalance_AllCreatureScript;
+    new VAS_AutoBalance_AllMapScript;
+    new VAS_AutoBalance_WorldMapScript;
+}
diff --git a/src/server/scripts/Custom/custom_script_loader.cpp b/src/server/scripts/Custom/custom_script_loader.cpp
index 5412cf1942..d7df80d68f 100644
--- a/src/server/scripts/Custom/custom_script_loader.cpp
+++ b/src/server/scripts/Custom/custom_script_loader.cpp
@@ -100,7 +100,8 @@
 // start82
 // start83
 // start84
-// start85
+// Vas Autobalance
+void AddSC_VAS_AutoBalance();
 // start86
 // start87
 // start88
@@ -305,7 +306,8 @@ void AddCustomScripts()
 // end82
 // end83
 // end84
-// end85
+// VAS AutoBalance
+    AddSC_VAS_AutoBalance();
 // end86
 // end87
 // end88
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 6ee9e3158c..c864516d74 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -58,6 +58,7 @@ PrepatchGI.Added = 0
 #    LOGGING SYSTEM SETTINGS
 #    PACKET SPOOF PROTECTION SETTINGS
 #    METRIC SETTINGS
+#    VAS AUTOBALANCE OPTIONS
 #
 ###################################################################################################
 
@@ -4016,6 +4017,77 @@ Metric.OverallStatusInterval = 1
 #
 ###################################################################################################
 
+###################################################################################################
+# VAS AUTOBALANCE OPTIONS
+#
+#     VAS.AutoBalance.XPlayer
+#        Set Server to level of solo mode.
+#        Set to 0 to Disable VAS-SOLO Mod.
+#        Example: VAS.AutoBalance.XPlayer = 1 will set everything for a 1 player game.
+#        Default:     1
+
+VAS.AutoBalance.XPlayer = 1
+
+#
+#     VAS.AutoBalance.AutoInstance
+#        Set instances to Auto chance XPlayer depending on players in it.
+#        Default:     1 (1 = ON, 0 = OFF)
+
+VAS.AutoBalance.AutoInstance = 1
+
+#
+#     VAS.AutoBalance.Debug
+#        0 = None
+#        1 = Errors Only
+#        2 = Errors and Basic Information
+#        3 = All VAS Info
+#        Default:     1
+
+VAS.AutoBalance.Debug = 2
+
+#
+#     VAS.AutoBalance.PlayerChangeNotify
+#        Set Auto Notifications to all players in Instance that player count has changed.
+#        Default:     1 (1 = ON, 0 = OFF)
+
+VAS.AutoBalance.PlayerChangeNotify = 1
+
+#
+#     VAS.AutoBalance.Color
+#        In Game Color for mod information in chat window.
+#        Default:     cffFF8000 (Orange)
+
+VAS.AutoBalance.Color = cffFF8000
+
+#
+#     Min.HP.Mod
+#        Minimum Modifier setting for Health Modification
+#        Default:     0.20
+
+Min.HP.Mod = 0.20
+
+#
+#     Min.D.Mod
+#        Minimum Modifier setting for Damage Modification
+#        Default:     0.10
+
+Min.D.Mod = 0.10
+
+#
+#     VAS.AutoBalance.XX.Name
+#        Sets MobIDs for the group they belong to.
+#        All 5 Man Mobs should go in VAS.AutoBalance.5.Name
+#        All 10 Man Mobs should go in VAS.AutoBalance.10.Name etc.
+
+VAS.AutoBalance.40.Name = "11583,16441,30057,13020,15589,14435,18192,14889,14888,14887,14890,15302,15818,15742,15741,15740,18338"
+VAS.AutoBalance.25.Name = "22997,21966,21965,21964,21806,21215,21845,19728,12397,17711,18256,18192,"
+VAS.AutoBalance.10.Name = "15689,15550,16152,17521,17225,16028,29324,31099"
+VAS.AutoBalance.5.Name = "15203,15204,15205,15305,6109,26801,30508,26799,30495,26803,30497,27859,27249"
+VAS.AutoBalance.2.Name = "25549,24558,25574,24559,25556,25557,25578,24561,25555,24555,25541,24553,25550,24554,24552,25564,15931,29373"
+
+#
+###################################################################################################
+
 #
 # Prepatch by LordPsyan.
 # See http://www.realmsofwarcraft.com/bb for forums and information.
-- 
2.11.0

