From ea166c6383d167214462051bc3da4e1d1860c5c8 Mon Sep 17 00:00:00 2001
From: LordPsyan <realmsofwarcraft@gmail.com>
Date: Sun, 28 Jan 2018 09:07:19 -0500
Subject: [PATCH] 2018_01_27-Dire_Maul_Arena

---
 .../Dire_Maul/world_dire_maul_arena.sql            |   29 +
 src/server/scripts/Custom/custom_script_loader.cpp |    6 +-
 src/server/scripts/Custom/npcs_dm_battle.cpp       | 2480 ++++++++++++++++++++
 src/server/scripts/Custom/npcs_dm_battle.h         |  369 +++
 4 files changed, 2882 insertions(+), 2 deletions(-)
 create mode 100644 sql/LordPsyan-Patches/Dire_Maul/world_dire_maul_arena.sql
 create mode 100644 src/server/scripts/Custom/npcs_dm_battle.cpp
 create mode 100644 src/server/scripts/Custom/npcs_dm_battle.h

diff --git a/sql/LordPsyan-Patches/Dire_Maul/world_dire_maul_arena.sql b/sql/LordPsyan-Patches/Dire_Maul/world_dire_maul_arena.sql
new file mode 100644
index 0000000..496ad46
--- /dev/null
+++ b/sql/LordPsyan-Patches/Dire_Maul/world_dire_maul_arena.sql
@@ -0,0 +1,29 @@
+
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88002,0,0,0,0,0,18653,18653,18653,18653,'Mini Blood Guard','','',0,80,80,0,16,0,1,1.14286,1,0,0,1209,1414,1,1,1,0,0,0,0,0,0,0,0,0,7,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,3,'',0,1,0,0,0,0,0,0,0,1,1,0,0,'npc_red_blood_mini',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88003,0,0,0,0,0,18653,18653,18653,18653,'Mini Blood Guard','','',0,80,80,0,16,0,1,1.14286,1,0,0,781,834,1,1,1,0,0,0,0,0,0,0,0,0,7,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,3,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_red_blood_mini',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88004,0,0,0,0,0,18653,18653,18653,18653,'Mini Blood Guard','','',0,80,80,0,16,0,1,1.14286,1,0,0,781,982,1,1,1,0,0,0,0,0,0,0,0,0,7,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,3,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_red_blood_mini',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88500,0,0,0,0,0,169,0,0,0,'Wave Spawn Trigger','','',0,1,1,0,16,0,1,1.14286,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_wave_trigger',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88501,0,0,0,0,0,27393,0,0,0,'Portal','','',0,1,1,0,35,0,1,1.14286,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,10,1024,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,12,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_wave_portals',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88001,0,0,0,0,0,18653,18653,18653,18653,'Red Blood Guard','','',0,80,80,0,16,0,1,1.14286,1,0,0,781,1021,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,13,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dire_maul_rb_guard',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (80700,0,0,0,0,0,28930,28930,28930,28930,'Arena Commander','Arena Commander','',0,80,80,0,35,1,1,0.91,1,3,0,4781,6231,1,1,1,0,0,0,0,0,0,0,0,0,7,0,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,5,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dire_arena_commander',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (80050,0,0,0,0,0,24842,0,0,0,'Garm Watcher','','',0,80,80,0,16,0,1,1.14286,1,0,0,387,543,1,1,1,0,0,0,0,0,0,0,0,0,7,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_wave_spawns',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (80051,0,0,0,0,0,26740,0,0,0,'Frigid Proto-Drake','','',0,80,80,0,16,0,1,1.14286,1,0,2,422,586,1,1,2,0,0,0,0,0,0,0,0,0,7,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_wave_spawns',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (80052,0,0,0,0,0,25495,0,0,0,'Osterkil','','',0,80,80,0,16,0,1,1.14286,1,0,0,431,582,1,1,1,0,0,0,0,0,0,0,0,0,7,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_wave_spawns',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (80053,0,0,0,0,0,27541,0,0,0,'Blight Falconer','','',0,80,80,0,16,0,1,1.14286,1,0,0,417,582,1,1,1,0,0,0,0,0,0,0,0,0,7,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_wave_spawns',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (80054,0,0,0,0,0,27776,27777,27778,27779,'Converted Hero','','',0,80,80,0,16,0,1,1.14286,1,0,0,417,582,1,1,1,0,0,0,0,0,0,0,0,0,7,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_wave_spawns',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88011,0,0,0,0,0,27930,0,0,0,'Hank the Tank','Arena Defender','',0,80,80,0,16,0,1,1.14286,1,2,0,341,454,1,1,1,0,0,0,0,0,0,0,0,0,7,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,18,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_hank_the_tank',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88012,0,0,0,0,0,17544,0,0,0,'Field Medic','Hank the Tank\'s Guardian','',0,80,80,0,16,0,1,1.14286,1,2,0,189,232,1,1,1,0,0,0,0,0,0,0,0,0,7,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,20,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_field_medic',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88013,0,0,0,0,0,24918,0,0,0,'Rogue Initiate','Arena Champion','',0,80,80,0,16,0,1,1.14286,1,1,3,331,546,1,1,3,0,0,0,0,0,0,0,0,0,7,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,20,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_main_rogue',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88014,0,0,0,0,0,24919,0,0,0,'Rogue Initiate','Minion of the Champ','',0,80,80,0,16,0,1,1.14286,1,1,3,273,341,1,1,3,0,0,0,0,0,0,0,0,0,7,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,16,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_rogue_initiate',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88015,0,0,0,0,0,24919,0,0,0,'Rogue Initiate','Minion of the Champ','',0,80,80,0,16,0,1,1.14286,1,1,3,273,341,1,1,3,0,0,0,0,0,0,0,0,0,7,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,16,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_rogue_initiate',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88016,0,0,0,0,0,25446,0,0,0,'The Unholy','Arena Gladiator','',0,80,80,0,16,0,1,1.14286,1,0,2,782,992,1,1,2,0,0,0,0,0,0,0,0,0,7,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,22,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_main_unholy',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88017,0,0,0,0,0,25496,0,0,0,'The Unholy Twin','','',0,80,80,0,16,0,1,1.14286,1,0,2,681,893,1,1,2,0,0,0,0,0,0,0,0,0,7,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,19,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_unholy_twin',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88018,0,0,0,0,0,25467,0,0,0,'Guin','Pet of The Unholy','',0,80,80,0,16,0,1,1.14286,1,0,0,221,432,1,1,1,0,0,0,0,0,0,0,0,0,7,0,0,0,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,13,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_unholy_pet',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88019,0,0,0,0,0,25083,0,0,0,'Riders Guardian','Arena Medic','',0,80,80,0,16,0,1,1.14286,1,1,0,331,341,1,1,1,0,0,0,0,0,0,0,0,0,7,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,18,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_rider_guardian',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88020,0,0,0,0,0,25082,0,0,0,'Rider Brute','Arena Brute','',0,80,80,0,16,0,1,1.14286,1,1,0,1331,1651,1,1,1,0,0,0,0,0,0,0,0,0,7,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,22,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_rider_brute',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88021,0,0,0,0,0,25082,0,0,0,'Rider Brute','Arena Brute','',0,80,80,0,16,0,1,1.14286,1,0,0,822,920,1,1,1,0,0,0,0,0,0,0,0,0,7,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,18,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_rider_brute',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88022,0,0,0,0,0,25015,0,0,0,'Arena Dragon','Spawn of Death','',0,82,82,0,16,0,1,1.14286,1,4,2,273,663,2,2,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,38,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'npc_dm_dragon_final',12340);
+REPLACE INTO `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`) values (88023,0,0,0,0,0,169,0,0,0,'Dragon Boss Trigger','','',0,80,80,0,16,0,1,1.14286,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,'',0,1,0,0,0,0,0,1,0,1,1,0,0,'',12340);
+
+UPDATE creature_template SET ScriptName='npc_army_ghoul' WHERE entry='24207';
+UPDATE `creature_template` SET `ScriptName`='npc_dm_wave_portals' WHERE (`entry`='88501')
\ No newline at end of file
diff --git a/src/server/scripts/Custom/custom_script_loader.cpp b/src/server/scripts/Custom/custom_script_loader.cpp
index 5412cf1..70d23d2 100644
--- a/src/server/scripts/Custom/custom_script_loader.cpp
+++ b/src/server/scripts/Custom/custom_script_loader.cpp
@@ -213,7 +213,8 @@
 // start195
 // start196
 // start197
-// start198
+// Dire Maul Event
+void AddSC_arena_link_battle();
 // start199
 // start200
 
@@ -418,7 +419,8 @@ void AddCustomScripts()
 // end195
 // end196
 // end197
-// end198
+// Dire Maul Event
+    AddSC_arena_link_battle();
 // end199
 // end200
 }
diff --git a/src/server/scripts/Custom/npcs_dm_battle.cpp b/src/server/scripts/Custom/npcs_dm_battle.cpp
new file mode 100644
index 0000000..7112786
--- /dev/null
+++ b/src/server/scripts/Custom/npcs_dm_battle.cpp
@@ -0,0 +1,2480 @@
+/**********************************************************
+**********************************************************
+ *                      Title:                          *
+  *            NPC Arena Battle(Dire Maul)             *
+   *                                                  *
+    *             Idea by: QQrofl                    *
+     *            Sub-Ideas by: Foereaper           *
+      *            Scripted by: QQrofl             *
+       *              Fondled by: Faded           *
+        *    Mental Support by: Foereaper        *
+         *        Updated by: LordPsyan         *
+          *                                    *
+*##########*##################################*##########*
+*        MAIN SPAWN                                      *
+*    Arena Commander:  Entry: 80700                      *
+*    -3815.866699f, 1102.770874f, 132.355194f, 6.182988f *
+*########################################################*/
+#include "ScriptPCH.h"
+#include "npcs_dm_battle.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Log.h"
+#include "CombatAI.h"
+#include "CreatureTextMgr.h"
+#include "GameEventMgr.h"
+#include "GameObject.h"
+#include "GossipDef.h"
+#include "ScriptedCreature.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+#include "Chat.h"
+#include "WorldSession.h"
+#include "Unit.h"
+#include "World.h"
+
+class npc_dire_arena_commander : public CreatureScript
+{
+   public:
+       npc_dire_arena_commander() : CreatureScript("npc_dire_arena_commander") { }
+
+       static bool OnGossipHello(Player * player, Creature * creature)
+       {
+           if(player->IsInCombat())
+               return false;
+
+           if(isBattleActive)
+               AddGossipItemFor(player, GOSSIP_ICON_BATTLE, "I'm sorry, but a battle is already active.", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+3);
+           else
+               AddGossipItemFor(player, GOSSIP_ICON_BATTLE, MSG_FIGHT_COMPUTER, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+           AddGossipItemFor(player, GOSSIP_ICON_DOT, "Nevermind", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+           SendGossipMenuFor(player, 1, creature->GetGUID());
+           return true;
+       }
+
+       static bool OnGossipSelect(Player * player, Creature * creature, uint32 sender, uint32 actions)
+       {
+           if(sender != GOSSIP_SENDER_MAIN)
+               return false;
+           player->PlayerTalkClass->ClearMenus();
+           switch(actions)
+           {
+              case GOSSIP_ACTION_INFO_DEF+1:
+                   m_PlayerGUID = player->GetGUID();
+                   playerName = player->GetName();
+                   isBattleActive = true;
+                   player->CastSpell(player, SPELL_TELEPORT_VISUAL, true);
+                   player->TeleportTo(1, -3739.533447f, 1095.419434f, 131.969559f, 3.029968f);
+                   CloseGossipMenuFor(player);
+                  break;
+
+              case GOSSIP_ACTION_INFO_DEF+2:
+                      CloseGossipMenuFor(player);
+                  break;
+
+              case GOSSIP_ACTION_INFO_DEF+3:
+                      CloseGossipMenuFor(player);
+                  break;
+           }
+           return true;
+       }
+
+       struct npc_dire_arena_commanderAI : public ScriptedAI
+       {
+           npc_dire_arena_commanderAI(Creature * c) : ScriptedAI(c), summons(me) { }
+
+           uint32 checkBattle;
+           uint32 checkPlayer;
+           bool checkIsDead;
+           bool resetOnce;
+
+           void Reset()
+           {
+               events.Reset();
+               player = 0;
+               summons.DespawnAll();
+               checkIsDead = true;
+               resetOnce = false;
+               checkBattle = 2000;
+               checkPlayer = 1000;
+           }
+
+           void UpdateAI(const uint32 diff)
+           {
+               events.Update(diff);
+
+               if(checkBattle <= diff)
+               {
+                   if(!isBattleActive && m_PlayerGUID == 0 && !resetOnce)
+                   {
+                       events.Reset();
+                       resetOnce = true;
+                   }
+
+                   if(isBattleActive && m_PlayerGUID != 0 && resetOnce)
+                   {
+                       player = ObjectAccessor::GetPlayer(*me, m_PlayerGUID);
+                       events.ScheduleEvent(EVENT_CHECK_ACTIVITY, 1000);
+                       resetOnce = false;
+                   }
+                   if(resetOnce)
+                       checkBattle = 2000;
+               }
+               else
+                   checkBattle -= diff;
+
+               if(checkPlayer <= diff) // Checking battle as well
+               {
+                   if(m_PlayerGUID == 0)
+                       return;
+
+                   if(hasLogged || !inZone)
+                   {
+                        isBattleActive = false;
+                        summons.DespawnAll();
+                        events.Reset();
+                        isWaveBossDead = 0;
+                        checkIsDead = true;
+                        hasLogged = false;
+                        inZone = true;
+                        resetOnce = false;
+                        player = 0;
+                        //m_PlayerGUID = 0;
+                        playerName = "";
+                        sWorld->SendGlobalText("A challenger has been scared off and left the Dire Maul Arena Challenge! Who's next?", nullptr);
+                   }
+                    checkPlayer = 1000;
+               }
+               else
+                   checkPlayer -= diff;
+
+               if (isWaveBossDead == 1 && checkIsDead)
+               {
+                   events.ScheduleEvent(EVENT_CHECK_WAVES, 1000);
+                   checkIsDead = false;
+               }
+               else if (isWaveBossDead == 2 && !checkIsDead)
+               {
+                   events.ScheduleEvent(EVENT_CHECK_WAVES, 1000);
+                   checkIsDead = true;
+               }
+               else if (isWaveBossDead == 3 && checkIsDead)
+               {
+                   events.ScheduleEvent(EVENT_CHECK_WAVES, 1000);
+                   checkIsDead = false;
+               }
+               else if (isWaveBossDead == 4 && !checkIsDead)
+               {
+                   events.ScheduleEvent(EVENT_CHECK_WAVES, 1000);
+                   checkIsDead = true;
+               }
+               else if (isWaveBossDead == 5 && checkIsDead)
+               {
+                   events.ScheduleEvent(EVENT_CHECK_WAVES, 1000);
+                   checkIsDead = false;
+               }
+               else if (isWaveBossDead == 6 && !checkIsDead)
+               {
+                   events.ScheduleEvent(EVENT_CHECK_WAVES, 1000);
+                   checkIsDead = true;
+               }
+               else if (isWaveBossDead == 7 && checkIsDead)
+               {
+                   events.ScheduleEvent(EVENT_CHECK_WAVES, 1000);
+                   checkIsDead = false;
+               }
+
+               while(uint32 eventIds = events.ExecuteEvent())
+               {
+                   switch(eventIds)
+                   {
+                      case EVENT_CHECK_ACTIVITY:
+                          {
+                              if(isBattleActive)
+                              {
+                                   MessageOnWave(me, EVENT_CHECK_ACTIVITY);
+                                   events.ScheduleEvent(EVENT_FIRST_WAVE, 10000);
+                              }
+                               else
+                                   events.ScheduleEvent(EVENT_CHECK_ACTIVITY, 1000);
+                          }break;
+
+                      case EVENT_CHECK_WAVES:
+                          {
+                              if(!player)
+                                  return;
+
+                              if(!isBattleActive)
+                              {
+                                  summons.DespawnAll();
+                                  checkIsDead = true;
+                                  resetOnce = false;
+                                  return;
+                              }
+
+                              int itemCount = player->GetItemCount(ITEM_INTRAVENOUS_HEALING_POTION);
+                              if(itemCount == 0)
+                                  player->AddItem(ITEM_INTRAVENOUS_HEALING_POTION, 1);
+                              if(isWaveBossDead == 1) // Red Blood Guard
+                              {
+                                  MessageOnWave(me, EVENT_CHECK_WAVES);
+                                  player->CastSpell(player, SPELL_TELEPORT_VISUAL, true);
+                                  player->TeleportTo(1, -3739.533447f, 1095.419434f, 131.969559f, 3.029968f);
+                                  AddEndRewards(nullptr, player, 500, PVP_END_TOKEN, 1);
+                                  events.ScheduleEvent(EVENT_FIRST_WAVE_TREAT, 25000);
+                                  isWaveBossDead = 0;
+                              }
+
+                              if (isWaveBossDead == 2) // Spawn Event
+                              {
+                                  MessageOnWave(me, EVENT_CHECK_WAVES);
+                                  player->CastSpell(player, SPELL_TELEPORT_VISUAL, true);
+                                  player->TeleportTo(1, -3739.533447f, 1095.419434f, 131.969559f, 3.029968f);
+                                  AddEndRewards(nullptr, player, 1000, PVP_END_TOKEN, 2);
+                                  events.ScheduleEvent(EVENT_FIRST_WAVE_ELITE, 35000);
+                                  isWaveBossDead = 0;
+                              }
+
+                              if(isWaveBossDead == 3) // Hank the Tank
+                              {
+                                  MessageOnWave(me, EVENT_CHECK_WAVES);
+                                  AddEndRewards(nullptr, player, 2000, PVP_END_TOKEN, 5);
+                                  player->CastSpell(player, SPELL_TELEPORT_VISUAL, true);
+                                  player->TeleportTo(1, -3739.533447f, 1095.419434f, 131.969559f, 3.029968f);
+                                  events.ScheduleEvent(EVENT_SECOND_WAVE, 35000);
+                                  isWaveBossDead = 0;
+                              }
+
+                              if(isWaveBossDead == 4) // Rogue Initiates
+                              {
+                                  MessageOnWave(me, EVENT_CHECK_WAVES);
+                                  AddEndRewards(nullptr, player, 3000, PVP_END_TOKEN, 10);
+                                  player->CastSpell(player, SPELL_TELEPORT_VISUAL, true);
+                                  player->TeleportTo(1, -3739.533447f, 1095.419434f, 131.969559f, 3.029968f);
+                                  events.ScheduleEvent(EVENT_SECOND_WAVE_TREAT, 35000);
+                                  isWaveBossDead = 0;
+                              }
+
+                              if(isWaveBossDead == 5) // The Unholys
+                              {
+                                  MessageOnWave(me, EVENT_CHECK_WAVES);
+                                  player->CastSpell(player, SPELL_TELEPORT_VISUAL, true);
+                                  AddEndRewards(nullptr, player, 4000, PVP_END_TOKEN, 20);
+                                  player->TeleportTo(1, -3739.533447f, 1095.419434f, 131.969559f, 3.029968f);
+                                  events.ScheduleEvent(EVENT_SECOND_WAVE_ELITE, 40000);
+                                  isWaveBossDead = 0;
+                              }
+
+                              if(isWaveBossDead == 6) // The Riders of the Ice
+                              {
+                                  MessageOnWave(me, EVENT_CHECK_WAVES);
+                                  player->CastSpell(player, SPELL_TELEPORT_VISUAL, true);
+                                  AddEndRewards(nullptr, player, 5000, PVP_END_TOKEN, 30);
+                                  player->TeleportTo(1, -3739.533447f, 1095.419434f, 131.969559f, 3.029968f);
+                                  events.ScheduleEvent(EVENT_FINAL_WAVE_BOSS, 35000);
+                                  isWaveBossDead = 0;
+                              }
+
+                              if(isWaveBossDead == 7) // Dragon Final Event
+                              {
+                                  MessageOnWave(me, EVENT_CHECK_WAVES);
+                                  player->CastSpell(player, SPELL_TELEPORT_VISUAL, true);
+                                  AddEndRewards(nullptr, player, 10000, PVP_END_TOKEN, 50);
+                                  events.ScheduleEvent(EVENT_COMPLETED_WAVES, 5000);
+                                  isWaveBossDead = 0;
+                              }
+                          }break;
+
+                      case EVENT_FIRST_WAVE:
+                          TC_LOG_DEBUG("events.dire", "[Dire Maul Arena]: Starting First Wave...");
+                          MessageOnWave(me, EVENT_FIRST_WAVE);
+                          player->CastSpell(player, SPELL_TELEPORT_VISUAL, true);
+                          player->TeleportTo(1, -3739.533447f, 1095.419434f, 131.969559f, 3.029968f); // Making sure you're in the right place
+                          player->PlayDirectSound(SOUND_HORN_WAVE_START);
+                          me->SummonCreature(waveList[0], m_WaveSpawns[0].m_positionX, m_WaveSpawns[0].m_positionY, m_WaveSpawns[0].m_positionZ, m_WaveSpawns[0].m_orientation,
+                              TEMPSUMMON_MANUAL_DESPAWN, 0);
+                          break;
+
+                      case EVENT_FIRST_WAVE_TREAT:
+                          MessageOnWave(me, EVENT_FIRST_WAVE_TREAT);
+                          me->SummonCreature(waveList[1], -3739.533447f, 1095.419434f, 131.969559f, 3.029968f, TEMPSUMMON_MANUAL_DESPAWN, 0);
+                          me->SummonCreature(NPC_PORTAL, m_WaveSpawns[1].m_positionX, m_WaveSpawns[1].m_positionY, m_WaveSpawns[1].m_positionZ, m_WaveSpawns[1].m_orientation,
+                                TEMPSUMMON_MANUAL_DESPAWN, 0);
+                          me->SummonCreature(NPC_PORTAL, m_WaveSpawns[2].m_positionX, m_WaveSpawns[2].m_positionY, m_WaveSpawns[2].m_positionZ, m_WaveSpawns[2].m_orientation,
+                                TEMPSUMMON_MANUAL_DESPAWN, 0);
+                          player->CastSpell(player, SPELL_TELEPORT_VISUAL, true);
+                          player->TeleportTo(1, -3739.533447f, 1095.419434f, 131.969559f, 3.029968f); // Making sure you're in the right place
+                          player->PlayDirectSound(SOUND_HORN_WAVE_START);
+                          break;
+
+                      case EVENT_FIRST_WAVE_ELITE:
+                          MessageOnWave(me, EVENT_FIRST_WAVE_ELITE);
+                          player->PlayDirectSound(SOUND_HORN_WAVE_START);
+                          player->CastSpell(player, SPELL_TELEPORT_VISUAL, true);
+                          player->TeleportTo(1, -3739.533447f, 1095.419434f, 131.969559f, 3.029968f); // Making sure you're in the right place
+                          me->SummonCreature(waveList[8], m_WaveSpawns[0].m_positionX, m_WaveSpawns[0].m_positionY, m_WaveSpawns[0].m_positionZ, m_WaveSpawns[0].m_orientation,
+                                TEMPSUMMON_MANUAL_DESPAWN, 0);
+                          break;
+
+                      case EVENT_SECOND_WAVE:
+                          MessageOnWave(me, EVENT_SECOND_WAVE);
+                          player->PlayDirectSound(SOUND_HORN_WAVE_START);
+                          player->CastSpell(player, SPELL_TELEPORT_VISUAL, true);
+                          player->TeleportTo(1, -3739.533447f, 1095.419434f, 131.969559f, 3.029968f); // Making sure you're in the right place
+                          me->SummonCreature(waveList[10], m_WaveSpawns[0].m_positionX, m_WaveSpawns[0].m_positionY, m_WaveSpawns[0].m_positionZ, m_WaveSpawns[0].m_orientation,
+                                TEMPSUMMON_MANUAL_DESPAWN, 0);
+                          break;
+
+                      case EVENT_SECOND_WAVE_TREAT:
+                          MessageOnWave(me, EVENT_SECOND_WAVE_TREAT);
+                          player->PlayDirectSound(SOUND_HORN_WAVE_START);
+                          player->CastSpell(player, SPELL_TELEPORT_VISUAL, true);
+                          player->TeleportTo(1, -3739.533447f, 1095.419434f, 131.969559f, 3.029968f); // Making sure you're in the right place
+                          me->SummonCreature(waveList[13], m_WaveSpawns[0].m_positionX, m_WaveSpawns[0].m_positionY, m_WaveSpawns[0].m_positionZ, m_WaveSpawns[0].m_orientation,
+                                TEMPSUMMON_MANUAL_DESPAWN, 0);
+                          break;
+
+                      case EVENT_SECOND_WAVE_ELITE:
+                          MessageOnWave(me, EVENT_SECOND_WAVE_ELITE);
+                          player->PlayDirectSound(SOUND_HORN_WAVE_START);
+                          player->CastSpell(player, SPELL_TELEPORT_VISUAL, true);
+                          player->TeleportTo(1, -3739.533447f, 1095.419434f, 131.969559f, 3.029968f); // Making sure you're in the right place
+                          me->SummonCreature(waveList[16], m_WaveSpawns[0].m_positionX, m_WaveSpawns[0].m_positionY, m_WaveSpawns[0].m_positionZ, m_WaveSpawns[0].m_orientation,
+                                TEMPSUMMON_MANUAL_DESPAWN, 0);
+                          break;
+
+                      case EVENT_FINAL_WAVE_BOSS:
+                          TC_LOG_DEBUG("events.dire", "[Dire Maul Arena]: Starting Final Wave...");
+                          MessageOnWave(me, EVENT_FINAL_WAVE_BOSS);
+                          player->PlayDirectSound(SOUND_HORN_WAVE_START);
+                          player->CastSpell(player, SPELL_TELEPORT_VISUAL, true);
+                          player->TeleportTo(1, -3739.533447f, 1095.419434f, 131.969559f, 3.029968f); // Making sure you're in the right place
+                          me->SummonCreature(waveList[19], m_WaveSpawns[0].m_positionX, m_WaveSpawns[0].m_positionY, m_WaveSpawns[0].m_positionZ, m_WaveSpawns[0].m_orientation,
+                                TEMPSUMMON_MANUAL_DESPAWN, 0);
+                          break;
+
+                      case EVENT_COMPLETED_WAVES:
+                          me->Yell("Congratulations to our finest Gladiator that went through a lot to earn our rewards! Who will be our next challenger?",
+                              LANG_UNIVERSAL, me);
+                          DoSendCompleteMessage(player->GetName());
+                          player->TeleportTo(1, sTeleOut[0].m_positionX, sTeleOut[0].m_positionY, sTeleOut[0].m_positionZ, sTeleOut[0].m_orientation);
+                          isBattleActive = false;
+                          //m_PlayerGUID = 0;
+                          playerName = "";
+                          summons.DespawnAll();
+                          events.Reset();
+                          isWaveBossDead = 0;
+                          checkIsDead = true;
+                          break;
+                    }
+                }
+           }
+
+           void JustSummoned(Creature * summoned)
+           {
+               summons.Summon(summoned);
+           }
+       private:
+           EventMap events;
+           Player * player;
+           SummonList summons;
+       };
+
+    static bool OnGossipSelectCode(Player* player, Creature* m_creature, uint32 sender, uint32 action, char const* code)
+        {
+            player->PlayerTalkClass->ClearMenus();
+            // code
+            return true;
+        }
+    struct MyAI : public ScriptedAI
+        {
+            MyAI(Creature* m_creature) : ScriptedAI(m_creature) { }
+            bool GossipHello(Player* player) override
+            {
+                return OnGossipHello(player, me);
+            }
+            bool GossipSelect(Player* player, uint32 menuId, uint32 gossipListId) override
+            {
+                uint32 sender = player->PlayerTalkClass->GetGossipOptionSender(gossipListId);
+                uint32 action = player->PlayerTalkClass->GetGossipOptionAction(gossipListId);
+                return OnGossipSelect(player, me, sender, action);
+            }
+            bool GossipSelectCode(Player* player, uint32 menuId, uint32 gossipListId, char const* code) override
+            {
+                uint32 sender = player->PlayerTalkClass->GetGossipOptionSender(gossipListId);
+                uint32 action = player->PlayerTalkClass->GetGossipOptionAction(gossipListId);
+                return OnGossipSelectCode(player, me, sender, action, code);
+            }
+        };
+
+    CreatureAI* GetAI(Creature* m_creature) const override
+        {
+            return new MyAI(m_creature);
+        }
+};
+
+class npc_dire_maul_rb_guard : public CreatureScript
+{
+   public:
+       npc_dire_maul_rb_guard() : CreatureScript("npc_dire_maul_rb_guard") { }
+
+       struct npc_dire_maul_rb_guardAI : public ScriptedAI
+       {
+           npc_dire_maul_rb_guardAI(Creature * c) : ScriptedAI(c), summons(me) { }
+
+           uint32 uiCharge;
+           uint32 uiMortalStrike;
+           uint32 uiCheckOutOfRange;
+           bool spawnMinis;
+
+           void Reset()
+           {
+               spawnMinis = true;
+               uiCharge = 2000;
+               uiMortalStrike = urand(5000, 8000);
+               me->Yell("You can't defeat me!", LANG_UNIVERSAL, me);
+               me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, 45233);
+           }
+
+           void KilledUnit(Unit * who)
+           {
+               if(who && who->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               DoEndBattle(me, summons);
+           }
+
+           void JustDied(Unit * killer)
+           {
+               if(killer && killer->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               me->PlayDirectSound(SOUND_WAVE_COMPLETE, killer->ToPlayer());
+               isWaveBossDead = 1;
+               summons.DespawnAll();
+           }
+
+           void JustSummoned(Creature * summoned)
+           {
+               summons.Summon(summoned);
+               summoned->AI()->AttackStart(me->GetVictim());
+               summoned->GetMotionMaster()->MoveChase(me->GetVictim(), 100.0f);
+           }
+
+           void UpdateAI(const uint32 diff)
+           {
+               if(!UpdateVictim())
+               {
+                   summons.DespawnAll();
+                   return;
+               }
+
+               ScriptedAI::UpdateAI(diff);
+               if(!isBattleActive)
+               {
+                   me->DespawnOrUnsummon(1);
+                   return;
+               }
+
+               if(uiCharge <= diff)
+               {
+                   me->CastSpell(me->GetVictim(), SPELL_BERSERKER_CHARGE, true);
+                   uiCharge = 12000;
+               }
+               else
+                   uiCharge -= diff;
+
+               if(uiMortalStrike <= diff)
+               {
+                   me->CastSpell(me->GetVictim(), SPELL_MORTAL_STRIKE, true);
+                   me->CastSpell(me->GetVictim(), SPELL_DEEP_WOUNDS, true); // Cast deep wounds after Mortal strike
+                   uiMortalStrike = urand(5000, 120000);
+               }
+               else
+                   uiMortalStrike -= diff;
+
+               if(me->GetHealthPct() <= 45 && spawnMinis)
+               {
+                   me->Yell("Minions, come to my aid!", LANG_UNIVERSAL, me);
+                   me->SummonCreature(NPC_RED_BLOOD_GUARD_MINI, me->GetPositionX(), me->GetPositionY()+1, me->GetPositionZ(), me->GetOrientation(), TEMPSUMMON_MANUAL_DESPAWN, 0);
+                   me->SummonCreature(NPC_RED_BLOOD_GUARD_MINI2, me->GetPositionX()+2, me->GetPositionY()+1, me->GetPositionZ(), me->GetOrientation(), TEMPSUMMON_MANUAL_DESPAWN, 0);
+                   me->SummonCreature(NPC_RED_BLOOD_GUARD_MINI3, me->GetPositionX()+2, me->GetPositionY()+1, me->GetPositionZ(), me->GetOrientation(), TEMPSUMMON_MANUAL_DESPAWN, 0);
+                   spawnMinis = false;
+               }
+               DoMeleeAttackIfReady();
+           }
+       private:
+           SummonList summons;
+       };
+
+       CreatureAI * GetAI(Creature * pCreature) const
+       {
+           return new npc_dire_maul_rb_guardAI(pCreature);
+       }
+};
+
+class npc_red_blood_mini : public CreatureScript
+{
+   public:
+       npc_red_blood_mini() : CreatureScript("npc_red_blood_mini") { }
+
+       struct npc_red_blood_miniAI : public ScriptedAI
+       {
+           npc_red_blood_miniAI(Creature * c) : ScriptedAI(c) { me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, 45233); }
+
+           void KilledUnit(Unit * who)
+           {
+               if(who && who->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               DoEndBattle(me);
+           }
+       };
+
+       CreatureAI * GetAI(Creature * pCreature) const
+       {
+           return new npc_red_blood_miniAI(pCreature);
+       }
+};
+
+class npc_dm_wave_trigger : public CreatureScript
+{
+   public:
+       npc_dm_wave_trigger() : CreatureScript("npc_dm_wave_trigger") { }
+
+       struct npc_dm_wave_triggerAI : public ScriptedAI
+       {
+           npc_dm_wave_triggerAI(Creature * c) : ScriptedAI(c), summons(me) { }
+
+           uint32 startSpawnWave;
+           int spawnPhase;
+
+           void Reset()
+           {
+               startSpawnWave = 1000;
+               spawnPhase = 0;
+           }
+
+           void UpdateAI(const uint32 diff)
+           {
+               if(!isBattleActive)
+               {
+                   summons.DespawnAll();
+                   me->DespawnOrUnsummon(1);
+                   return;
+               }
+
+               if(startSpawnWave <= diff)
+               {
+                   switch(spawnPhase)
+                   {
+                      case 0:
+                          {
+                              spawnPhase = 1;
+                              DoPortalSpawns();
+                              startSpawnWave = 13000;
+                          }break;
+
+                      case 1:
+                          {
+                              spawnPhase = 2;
+                              DoPortalSpawns();
+                              startSpawnWave = 13000;
+                          }break;
+
+                      case 2:
+                          {
+                              spawnPhase = 3;
+                              DoPortalSpawns();
+                              startSpawnWave = 13000;
+                          }break;
+
+                      case 3:
+                          {
+                              spawnPhase = 4;
+                              for(int i = 0; i < 2; i++)
+                                DoPortalSpawns();
+                              startSpawnWave = 25000;
+                          }break;
+
+                      case 4:
+                          {
+                              spawnPhase = 5;
+                              for(int i = 0; i < 2; i++)
+                                DoPortalSpawns();
+                              startSpawnWave = 25000;
+                          }break;
+
+                      case 5:
+                          {
+                              spawnPhase = 6;
+                              for(int i = 0; i < 4; i++)
+                                DoPortalSpawns();
+                              startSpawnWave = 36000;
+                          }break;
+
+                      case 6:
+                          {
+                              spawnPhase = 7;
+                              for(int i = 0; i < 4; i++)
+                                DoPortalSpawns();
+                              startSpawnWave = 36000;
+                          }break;
+
+                      case 7:
+                          {
+                              spawnPhase = 8;
+                              DoPortalSpawns();
+                              startSpawnWave = 10000;
+                          }break;
+
+                      case 8:
+                          {
+                              spawnPhase = 9;
+                              DoPortalSpawns();
+                              startSpawnWave = 10000;
+                          }break;
+
+                      case 9:
+                          {
+                              spawnPhase = 10;
+                              DoPortalSpawns();
+                              startSpawnWave = 15000;
+                          }break;
+
+                      case 10:
+                          {
+                              spawnPhase = 11;
+                              for(int i = 0; i < 4; i++)
+                                DoPortalSpawns();
+                              startSpawnWave = 60000;
+                          }break;
+
+                      case 11:
+                          {
+                              if(Player * player = ObjectAccessor::GetPlayer(*me, m_PlayerGUID))
+                              {
+                                  if(!player)
+                                      return;
+                                  me->PlayDirectSound(SOUND_WAVE_COMPLETE, player);
+                              }
+                              isWaveBossDead = 2;
+                              summons.DespawnAll();
+                              spawnPhase = 0;
+                              me->DespawnOrUnsummon(1);
+                          }break;
+                   }
+               }
+               else
+                   startSpawnWave -= diff;
+           }
+
+           void JustSummoned(Creature * summoned)
+           {
+               summons.Summon(summoned);
+               if(Player * player = ObjectAccessor::GetPlayer(*me, m_PlayerGUID))
+               {
+                   if(!player)
+                       return;
+                   summoned->SetInCombatWith(player);
+                   summoned->AI()->AttackStart(player);
+                   summoned->GetMotionMaster()->MoveChase(player, 500.0f);
+               }
+           }
+
+           void DoPortalSpawns() // Spawns Random Npcs
+           {
+               int random = urand(0, 4);
+               switch(random)
+               {
+                   case 0:
+                       me->SummonCreature(waveList[2], m_WaveSpawns[1].m_positionX, m_WaveSpawns[1].m_positionY, m_WaveSpawns[1].m_positionZ, m_WaveSpawns[1].m_orientation,
+                           TEMPSUMMON_MANUAL_DESPAWN, 0);
+                       break;
+
+                   case 1:
+                       me->SummonCreature(waveList[3], m_WaveSpawns[1].m_positionX, m_WaveSpawns[1].m_positionY, m_WaveSpawns[1].m_positionZ, m_WaveSpawns[1].m_orientation,
+                           TEMPSUMMON_MANUAL_DESPAWN, 0);
+                       break;
+
+                   case 2:
+                       me->SummonCreature(waveList[4], m_WaveSpawns[1].m_positionX, m_WaveSpawns[1].m_positionY, m_WaveSpawns[1].m_positionZ, m_WaveSpawns[1].m_orientation,
+                           TEMPSUMMON_MANUAL_DESPAWN, 0);
+                       break;
+
+                   case 3:
+                       me->SummonCreature(waveList[5], m_WaveSpawns[1].m_positionX, m_WaveSpawns[1].m_positionY, m_WaveSpawns[1].m_positionZ, m_WaveSpawns[1].m_orientation,
+                           TEMPSUMMON_MANUAL_DESPAWN, 0);
+                       break;
+
+                   case 4:
+                       me->SummonCreature(waveList[6], m_WaveSpawns[1].m_positionX, m_WaveSpawns[1].m_positionY, m_WaveSpawns[1].m_positionZ, m_WaveSpawns[1].m_orientation,
+                           TEMPSUMMON_MANUAL_DESPAWN, 0);
+                       break;
+               }
+               int random2 = urand(0, 4);
+               switch(random2)
+               {
+                   case 0:
+                       me->SummonCreature(waveList[2], m_WaveSpawns[2].m_positionX, m_WaveSpawns[2].m_positionY, m_WaveSpawns[2].m_positionZ, m_WaveSpawns[2].m_orientation,
+                           TEMPSUMMON_MANUAL_DESPAWN, 0);
+                       break;
+
+                   case 1:
+                       me->SummonCreature(waveList[3], m_WaveSpawns[2].m_positionX, m_WaveSpawns[2].m_positionY, m_WaveSpawns[2].m_positionZ, m_WaveSpawns[2].m_orientation,
+                           TEMPSUMMON_MANUAL_DESPAWN, 0);
+                       break;
+
+                   case 2:
+                       me->SummonCreature(waveList[4], m_WaveSpawns[2].m_positionX, m_WaveSpawns[2].m_positionY, m_WaveSpawns[2].m_positionZ, m_WaveSpawns[2].m_orientation,
+                           TEMPSUMMON_MANUAL_DESPAWN, 0);
+                       break;
+
+                   case 3:
+                       me->SummonCreature(waveList[5], m_WaveSpawns[2].m_positionX, m_WaveSpawns[2].m_positionY, m_WaveSpawns[2].m_positionZ, m_WaveSpawns[2].m_orientation,
+                           TEMPSUMMON_MANUAL_DESPAWN, 0);
+                       break;
+
+                   case 4:
+                       me->SummonCreature(waveList[6], m_WaveSpawns[2].m_positionX, m_WaveSpawns[2].m_positionY, m_WaveSpawns[2].m_positionZ, m_WaveSpawns[2].m_orientation,
+                           TEMPSUMMON_MANUAL_DESPAWN, 0);
+                       break;
+               }
+           }
+       private:
+           SummonList summons;
+       };
+
+       CreatureAI * GetAI(Creature * pCreature) const
+       {
+           return new npc_dm_wave_triggerAI(pCreature);
+       }
+};
+
+class npc_dm_wave_spawns : public CreatureScript
+{
+   public:
+       npc_dm_wave_spawns() : CreatureScript("npc_dm_wave_spawns") { }
+
+       struct npc_dm_wave_spawnsAI : public ScriptedAI
+       {
+           npc_dm_wave_spawnsAI(Creature * c) : ScriptedAI(c) { }
+
+           void KilledUnit(Unit * who)
+           {
+               if(who && who->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               DoEndBattle(me);
+           }
+
+           void UpdateAI(const uint32 diff)
+           {
+               if(!isBattleActive)
+                   me->DespawnOrUnsummon(1);
+
+               if(!UpdateVictim())
+                   return;
+
+               DoMeleeAttackIfReady();
+           }
+       };
+
+       CreatureAI * GetAI(Creature * pCreature) const
+       {
+           return new npc_dm_wave_spawnsAI(pCreature);
+       }
+};
+
+class npc_dm_wave_portals : public CreatureScript
+{
+   public:
+       npc_dm_wave_portals() : CreatureScript("npc_dm_wave_portals") { }
+
+       struct npc_dm_wave_portalsAI : public ScriptedAI
+       {
+           npc_dm_wave_portalsAI(Creature * c) : ScriptedAI(c) { }
+
+           void UpdateAI(const uint32 diff)
+           {
+               if(!isBattleActive)
+                   me->DespawnOrUnsummon(1);
+           }
+       };
+
+       CreatureAI * GetAI(Creature * pCreature) const
+       {
+           return new npc_dm_wave_portalsAI(pCreature);
+       }
+};
+
+uint32 hankAuras[] = { SPELL_BATTLE_STANCE, SPELL_INCREASE_BLOCK_VALUE, SPELL_INCREASE_DEFENSE_RATING, SPELL_INCREASE_DODGE_RATING };
+class npc_dm_hank_the_tank : public CreatureScript
+{
+   public:
+       npc_dm_hank_the_tank() : CreatureScript("npc_dm_hank_the_tank") { }
+
+       struct npc_dm_hank_the_tankAI : public ScriptedAI
+       {
+           npc_dm_hank_the_tankAI(Creature * c) : ScriptedAI(c), summons(me) { }
+
+           uint32 shoutBuff;
+           uint32 groundStomp;
+           uint32 uiExecute;
+           uint32 tankStrike;
+           uint32 uiRend;
+           uint32 shieldBlock;
+           uint32 shieldBash;
+
+           void Reset()
+           {
+               me->Yell("You will succumb to death, young scums!", LANG_UNIVERSAL, me);
+               summons.DespawnAll();
+               me->SummonCreature(waveList[9], me->GetPositionX(), me->GetPositionY()+3, me->GetPositionZ(), me->GetOrientation(), TEMPSUMMON_MANUAL_DESPAWN, 0);
+               shoutBuff = 1000;
+               groundStomp = 6000;
+               shieldBash = urand(9000, 13000);
+               uiExecute = urand(21000, 26000);
+               shieldBlock = 18000;
+               tankStrike = urand(4000, 8000);
+               uiRend = 11000;
+               me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID+0, 51516);
+               me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID+1, 51533);
+               for(int i = 0; i < 4; i++)
+                   me->AddAura(hankAuras[i], me);
+           }
+
+           void EnterCombat(Unit * who)
+           {
+               if(who && who->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               DoCast(who, SPELL_TANK_CHARGE);
+           }
+
+           void JustDied(Unit * killer)
+           {
+               if(killer && killer->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               me->PlayDirectSound(SOUND_WAVE_COMPLETE, killer->ToPlayer());
+               summons.DespawnAll();
+               isWaveBossDead = 3;
+           }
+
+           void KilledUnit(Unit * who)
+           {
+               if(who && who->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               DoEndBattle(me, summons);
+           }
+
+           void JustSummoned(Creature * summoned)
+           {
+               summons.Summon(summoned);
+           }
+
+           void UpdateAI(const uint32 diff)
+           {
+               if(!UpdateVictim())
+                   return;
+
+               if(!isBattleActive)
+               {
+                   summons.DespawnAll();
+                   me->DespawnOrUnsummon(1);
+                   return;
+               }
+
+               if(shoutBuff <= diff)
+               {
+                   me->AddAura(SPELL_SHOUT_BUFF, me);
+                   shoutBuff = 120000; // 2 minutes
+               }
+               else
+                   shoutBuff -= diff;
+
+               if(groundStomp <= diff)
+               {
+                   DoCast(me->GetVictim(), SPELL_GROUND_STOMP, true);
+                   groundStomp = 6000;
+               }
+               else
+                   groundStomp -= diff;
+
+               if(uiExecute <= diff)
+               {
+                   if(me->GetVictim()->GetHealthPct() <= 20)
+                       DoCast(me->GetVictim(), SPELL_EXECUTE);
+                   uiExecute = urand(21000, 26000);
+               }
+               else
+                   uiExecute -= diff;
+
+               if(shieldBlock <= diff)
+               {
+                   DoCast(me, SPELL_SHIELD_BLOCK); // Cast on self
+                   shieldBlock = 18000;
+               }
+               else
+                   shieldBlock -= diff;
+
+               if(tankStrike <= diff)
+               {
+                   DoCast(me->GetVictim(), SPELL_TANK_STRIKE);
+                   tankStrike = urand(4000, 8000);
+               }
+               else
+                   tankStrike -= diff;
+
+               if(uiRend <= diff)
+               {
+                   DoCast(me->GetVictim(), SPELL_REND, true);
+                   uiRend = 15000;
+               }
+               else
+                   uiRend -= diff;
+               DoMeleeAttackIfReady();
+           }
+       private:
+           SummonList summons;
+       };
+
+       CreatureAI * GetAI(Creature * pCreature) const
+       {
+           return new npc_dm_hank_the_tankAI(pCreature);
+       }
+};
+
+class npc_dm_field_medic : public CreatureScript
+{
+   public:
+       npc_dm_field_medic() : CreatureScript("npc_dm_field_medic") { }
+
+       struct npc_dm_field_medicAI : public ScriptedAI
+       {
+           npc_dm_field_medicAI(Creature * c) : ScriptedAI(c) { }
+
+           uint32 uiRegrowthTimer;
+           uint32 uiHealingTouchTimer;
+           uint32 uiHealRejuvTimer;
+           uint32 uiFlashHealTimer;
+           uint32 uiPowerShieldTimer;
+           uint32 uiLifebloomTimer;
+           int casted;
+           bool showOnce;
+           bool canHealMaster;
+
+           void Reset()
+           {
+               uiRegrowthTimer = urand(11000, 13000);
+               uiHealingTouchTimer = urand(6000, 8000);
+               uiHealRejuvTimer = 15000;
+               uiFlashHealTimer = urand(14000, 17000);
+               uiPowerShieldTimer = 1000;
+               uiLifebloomTimer = 2000;
+               canHealMaster = true;
+               showOnce = false;
+               int casted = 0;
+               me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID+0, 51404);
+               me->AddAura(SPELL_HEAL_AURA_HOTS, me);
+               hank = 0;
+               hank = me->FindNearestCreature(NPC_HANK_THE_TANK, 50.0f, true);
+           }
+
+           void UpdateAI(const uint32 diff)
+           {
+               if(!hank)
+                   return;
+
+               if(hank && hank->isDead() && !showOnce)
+               {
+                   me->Yell("Master Dead?!!! I give up!...", LANG_UNIVERSAL, me);
+                   me->SetFaction(35);
+                   me->DespawnOrUnsummon(1);
+                   showOnce = true;
+                   return;
+               }
+
+               if(hank && !hank->IsInCombat())
+                   return;
+
+               if(hank && hank->GetHealthPct() >= 100)
+                   canHealMaster = false;
+               else
+                   canHealMaster = true;
+
+               if(uiRegrowthTimer <= diff)
+               {
+                   if(canHealMaster)
+                       DoCast(hank, SPELL_HEAL_REGROWTH, true);
+                   if(me->GetHealthPct() <= 70)
+                       DoCast(me, SPELL_HEAL_REGROWTH, true);
+                   uiRegrowthTimer = urand(10000, 16000);
+               }
+               else
+                   uiRegrowthTimer -= diff;
+
+               if(uiHealingTouchTimer <= diff)
+               {
+                   if(hank->GetHealthPct() <= 45 && canHealMaster)
+                       DoCast(hank, SPELL_HEAL_NORMAL, true);
+                   if(me->GetHealthPct() <= 30)
+                       DoCast(me, SPELL_HEAL_NORMAL, true);
+                   uiHealingTouchTimer = urand(6000, 8000);
+               }
+               else
+                   uiHealingTouchTimer -= diff;
+
+               if(uiHealRejuvTimer <= diff)
+               {
+                   if(canHealMaster)
+                       DoCast(hank, SPELL_HEAL_REJUV, true);
+                   if(me->GetHealthPct() <= 90)
+                       DoCast(me, SPELL_HEAL_REJUV, true);
+                   uiHealRejuvTimer = 15000;
+               }
+               else
+                   uiHealRejuvTimer -= diff;
+
+               if(uiFlashHealTimer <= diff)
+               {
+                   if(canHealMaster)
+                       DoCast(hank, SPELL_FLASH_HEAL, true);
+                   if(me->GetHealthPct() <= 55)
+                       DoCast(me, SPELL_FLASH_HEAL, true);
+                   uiFlashHealTimer = urand(14000, 17000);
+               }
+               else
+                   uiFlashHealTimer -= diff;
+
+               if(uiPowerShieldTimer <= diff)
+               {
+                   DoCast(me, SPELL_POWER_WORD_SHIELD);
+                   uiPowerShieldTimer = 30000;
+               }
+               else
+                   uiPowerShieldTimer -= diff;
+
+               if(uiLifebloomTimer <= diff)
+               {
+                   if(canHealMaster)
+                   {
+                       DoCast(hank, SPELL_HEAL_LIFEBLOOM, true); // Stacking
+                       casted++; // Increment the value
+                       if(casted != 3)
+                           uiLifebloomTimer = 2000;
+                       else // Prevents further stacking of this spell
+                       {
+                           uiLifebloomTimer = 26000;
+                           casted = 0;
+                       }
+                   }
+               }
+               else
+                   uiLifebloomTimer -= diff;
+           }
+       private:
+           Creature * hank;
+       };
+
+       CreatureAI * GetAI(Creature * pCreature) const
+       {
+           return new npc_dm_field_medicAI(pCreature);
+       }
+};
+
+class npc_dm_main_rogue : public CreatureScript
+{
+   public:
+       npc_dm_main_rogue() : CreatureScript("npc_dm_main_rogue") { }
+
+       struct npc_dm_main_rogueAI : public ScriptedAI
+       {
+           npc_dm_main_rogueAI(Creature * c) : ScriptedAI(c), summons(me) { }
+
+           uint32 uiVanishTimer;
+           uint32 uiCheapShotTimer;
+           uint32 uiStrikeTimer;
+           uint32 uiFinisherTimer;
+           uint32 uiKickTimer;
+           uint32 uiWaitTimer;
+           uint32 uiRuptureTimer;
+           int comboPoints;
+           bool InStealth;
+           bool InVanish;
+
+           void Reset()
+           {
+               me->Yell("We'll teach you a valued lesson.", LANG_UNIVERSAL, me);
+               InStealth = true;
+               InVanish = false;
+               comboPoints = 0;
+               uiFinisherTimer = 4000;
+               uiStrikeTimer = 6000;
+               uiRuptureTimer = 9000;
+               uiKickTimer = 10000;
+               uiVanishTimer = 17000;
+               DoCast(me, SPELL_ROGUE_STEALTH);
+               me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID+0, 51517);
+               me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID+1, 51441);
+               summons.DespawnAll();
+               me->SummonCreature(waveList[11], m_WaveSpawns[0].m_positionX, m_WaveSpawns[0].m_positionY+3, m_WaveSpawns[0].m_positionZ, m_WaveSpawns[0].m_orientation, TEMPSUMMON_MANUAL_DESPAWN, 0);
+               me->SummonCreature(waveList[12], m_WaveSpawns[0].m_positionX, m_WaveSpawns[0].m_positionY-3, m_WaveSpawns[0].m_positionZ, m_WaveSpawns[0].m_orientation, TEMPSUMMON_MANUAL_DESPAWN, 0);
+           }
+
+           void JustDied(Unit * killer)
+           {
+               if(killer && killer->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               me->PlayDirectSound(SOUND_WAVE_COMPLETE, killer->ToPlayer());
+               summons.DespawnAll();
+               isWaveBossDead = 4;
+           }
+
+           void KilledUnit(Unit * who)
+           {
+               if(who && who->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               DoEndBattle(me, summons);
+           }
+
+           void JustSummoned(Creature * summoned)
+           {
+               summons.Summon(summoned);
+           }
+
+           void UpdateAI(const uint32 diff)
+           {
+               if(!UpdateVictim())
+                   return;
+
+               if(!isBattleActive)
+               {
+                   summons.DespawnAll();
+                   me->DespawnOrUnsummon(1);
+                   return;
+               }
+
+               if(InStealth)
+               {
+                   me->CastSpell(me->GetVictim(), SPELL_ROGUE_CHEAP_SHOT, true);
+                   InStealth = false;
+               }
+
+               if(uiStrikeTimer <= diff)
+               {
+                   if(!InVanish)
+                   {
+                       DoCast(me->GetVictim(), SPELL_ROGUE_STRIKE);
+                       comboPoints++;
+                   }
+                   uiStrikeTimer = 6000;
+               }
+               else
+                   uiStrikeTimer -= diff;
+
+               if(uiFinisherTimer <= diff)
+               {
+                   if(!InVanish && comboPoints >= 2)
+                   {
+                       me->CastSpell(me->GetVictim(), SPELL_ROGUE_FINISHER, true);
+                       comboPoints = 0;
+                   }
+                   uiFinisherTimer = 4000;
+               }
+               else
+                   uiFinisherTimer -= diff;
+
+               if(uiKickTimer <= diff)
+               {
+                   if(!InVanish)
+                       DoCast(me->GetVictim(), SPELL_ROGUE_KICK);
+                   uiKickTimer = 10000;
+               }
+               else
+                   uiKickTimer -= diff;
+
+               if(uiVanishTimer <= diff)
+               {
+                   DoCast(me, SPELL_ROGUE_VANISH);
+                   InVanish = true;
+                   uiVanishTimer = 20000;
+                   uiWaitTimer = 6000;
+               }
+               else
+                   uiVanishTimer -= diff;
+
+               if(uiRuptureTimer <= diff)
+               {
+                   if(!InVanish)
+                       DoCast(me->GetVictim(), SPELL_ROGUE_RUPTURE, true);
+                   uiRuptureTimer = 9000;
+               }
+               else
+                   uiRuptureTimer -= diff;
+
+               if(InVanish)
+               {
+                   if(uiWaitTimer <= diff)
+                   {
+                       me->CastSpell(me->GetVictim(), SPELL_ROGUE_CHEAP_SHOT, true);
+                       me->Yell("Attack!", LANG_UNIVERSAL, me);
+                       InVanish = false;
+                   }
+                   else
+                       uiWaitTimer -= diff;
+               }
+               if(!InVanish)
+                   DoMeleeAttackIfReady();
+           }
+       private:
+           SummonList summons;
+       };
+
+       CreatureAI * GetAI(Creature * pCreature) const
+       {
+           return new npc_dm_main_rogueAI(pCreature);
+       }
+};
+
+class npc_dm_rogue_initiate : public CreatureScript
+{
+   public:
+       npc_dm_rogue_initiate() : CreatureScript("npc_dm_rogue_initiate") { }
+
+       struct npc_dm_rogue_initiateAI : public ScriptedAI
+       {
+           npc_dm_rogue_initiateAI(Creature * c) : ScriptedAI(c) { }
+
+           uint32 uiVanishTimer;
+           uint32 uiCheapShotTimer;
+           uint32 uiStrikeTimer;
+           uint32 uiFinisherTimer;
+           uint32 uiKickTimer;
+           uint32 uiWaitTimer;
+           uint32 uiKidneyShotTimer;
+           int comboPoints;
+           bool InVanish;
+           bool InStealth;
+
+           void Reset()
+           {
+               InVanish = false;
+               InStealth = true;
+               comboPoints = 0;
+               uiFinisherTimer = 4000;
+               uiStrikeTimer = 6000;
+               uiKickTimer = 10000;
+               uiKidneyShotTimer = 14000;
+               uiVanishTimer = 17000;
+               DoCast(me, SPELL_ROGUE_STEALTH);
+               me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID+0, 51517);
+               me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID+1, 51441);
+           }
+
+           void KilledUnit(Unit * who)
+           {
+               if(who && who->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               DoEndBattle(me);
+           }
+
+           void UpdateAI(const uint32 diff)
+           {
+               if(!UpdateVictim())
+                   return;
+
+               if(InStealth)
+               {
+                   DoCast(me->GetVictim(), SPELL_ROGUE_BACKSTAB);
+                   InStealth = false;
+               }
+
+               if(uiStrikeTimer <= diff)
+               {
+                   if(!InVanish)
+                   {
+                       DoCast(me->GetVictim(), SPELL_ROGUE_STRIKE);
+                       comboPoints++;
+                   }
+                   uiStrikeTimer = 6000;
+               }
+               else
+                   uiStrikeTimer -= diff;
+
+               if(uiFinisherTimer <= diff)
+               {
+                   if(!InVanish && comboPoints >= 2)
+                   {
+                       me->CastSpell(me->GetVictim(), SPELL_ROGUE_FINISHER, true);
+                       comboPoints = 0;
+                   }
+                   uiFinisherTimer = 4000;
+               }
+               else
+                   uiFinisherTimer -= diff;
+
+               if(uiKickTimer <= diff)
+               {
+                   if(!InVanish)
+                       DoCast(me->GetVictim(), SPELL_ROGUE_KICK);
+                   uiKickTimer = 10000;
+               }
+               else
+                   uiKickTimer -= diff;
+
+               if(uiKidneyShotTimer <= diff)
+               {
+                   if(!InVanish)
+                       DoCast(me->GetVictim(), SPELL_ROGUE_KIDNEY_SHOT);
+                   uiKidneyShotTimer = 12000;
+               }
+               else
+                   uiKidneyShotTimer -= diff;
+
+               if(uiVanishTimer <= diff)
+               {
+                   DoCast(me, SPELL_ROGUE_VANISH);
+                   InVanish = true;
+                   uiVanishTimer = 20000;
+                   uiWaitTimer = 6000;
+               }
+               else
+                   uiVanishTimer -= diff;
+
+               if(InVanish)
+               {
+                   if(uiWaitTimer <= diff)
+                   {
+                       DoCast(me->GetVictim(), SPELL_ROGUE_BACKSTAB);
+                       InVanish = false;
+                   }
+                   else
+                       uiWaitTimer -= diff;
+               }
+               if(!InVanish)
+                   DoMeleeAttackIfReady();
+           }
+       };
+
+       CreatureAI * GetAI(Creature * pCreature) const
+       {
+           return new npc_dm_rogue_initiateAI(pCreature);
+       }
+};
+
+class npc_dm_main_unholy : public CreatureScript
+{
+   public:
+       npc_dm_main_unholy() : CreatureScript("npc_dm_main_unholy") { }
+
+       struct npc_dm_main_unholyAI : public ScriptedAI
+       {
+           npc_dm_main_unholyAI(Creature * c) : ScriptedAI(c), summons(me) { }
+
+           uint32 uiCinematic;
+           uint32 uiAoeTimer;
+           uint32 uiPlagueStrikeTimer;
+           uint32 uiStangulateTimer;
+           uint32 uiDeathStrikeTimer;
+           uint32 uiArmyOfTheDeadTimer;
+           int cinematicPassed;
+           bool checkGuin;
+           bool boneArmor;
+
+           void Reset()
+           {
+               me->Say("What is this? A trap?", LANG_UNIVERSAL, 0);
+               uiCinematic = 9000;
+               cinematicPassed = 0;
+               checkGuin = true;
+               boneArmor = true;
+               me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_NOT_SELECTABLE);
+               me->SetReactState(REACT_PASSIVE);
+               me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID+0, 51393);
+               summons.DespawnAll();
+               twin = me->SummonCreature(waveList[14], m_WaveSpawns[0].m_positionX, m_WaveSpawns[0].m_positionY+3, m_WaveSpawns[0].m_positionZ, m_WaveSpawns[0].m_orientation, TEMPSUMMON_MANUAL_DESPAWN, 0);
+               guin = me->SummonCreature(waveList[15], m_WaveSpawns[0].m_positionX, m_WaveSpawns[0].m_positionY-3, m_WaveSpawns[0].m_positionZ, m_WaveSpawns[0].m_orientation, TEMPSUMMON_MANUAL_DESPAWN, 0);
+           }
+
+           void KilledUnit(Unit * who)
+           {
+               if(who && who->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               DoEndBattle(me, summons);
+               twin = 0;
+               guin = 0;
+           }
+
+           void JustDied(Unit * killer)
+           {
+               if(killer && killer->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               me->PlayDirectSound(SOUND_WAVE_COMPLETE, killer->ToPlayer());
+               summons.DespawnAll();
+               twin = 0;
+               guin = 0;
+               isWaveBossDead = 5;
+           }
+
+           void UpdateAI(const uint32 diff)
+           {
+               if(!isBattleActive)
+               {
+                   summons.DespawnAll();
+                   twin = 0;
+                   guin = 0;
+                   me->DespawnOrUnsummon(1);
+                   return;
+               }
+
+               if(uiCinematic <= diff)
+               {
+                   switch(cinematicPassed)
+                   {
+                       case 0:
+                           me->Say("Ahh, so this thing wants to fight, huh?", LANG_UNIVERSAL, 0);
+                           cinematicPassed = 1;
+                           uiCinematic = 10000;
+                           break;
+
+                       case 1:
+                           me->Say("Don't be a fool!", LANG_UNIVERSAL, 0);
+                           cinematicPassed = 2;
+                           uiCinematic = 9000;
+                           break;
+
+                       case 2:
+                           me->Say("Twin, no! Let him go. We can just watch, for now....", LANG_UNIVERSAL, 0);
+                           cinematicPassed = 3;
+                           break;
+                   }
+               }
+               else
+                   uiCinematic -= diff;
+
+               if(checkGuin)
+               {
+                   if(guin && guin->isDead())
+                   {
+                       me->Yell("SO BE IT!", LANG_UNIVERSAL, me);
+                       me->AddAura(SPELL_UNHOLY_BONE_SHIELD, me);
+                       me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_NOT_SELECTABLE);
+                       uiAoeTimer = 25000;
+                       uiPlagueStrikeTimer = urand(5000, 8000);
+                       uiDeathStrikeTimer = urand(9000, 12000);
+                       uiStangulateTimer = 15000;
+                       uiArmyOfTheDeadTimer = 30000;
+                       me->SetReactState(REACT_AGGRESSIVE);
+                       if(twin)
+                       {
+                           twin->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_NOT_SELECTABLE);
+                           twin->SetReactState(REACT_AGGRESSIVE);
+                       }
+                       checkGuin = false;
+                   }
+               }
+
+               if(!UpdateVictim())
+                   return;
+
+               if(HealthBelowPct(25) && boneArmor)
+               {
+                   me->AddAura(SPELL_UNHOLY_BONE_SHIELD, me);
+                   boneArmor = false;
+               }
+
+               if(uiAoeTimer <= diff)
+               {
+                   me->CastSpell(me->GetVictim(), SPELL_UNHOLY_AOE, true);
+                   uiAoeTimer = 25000;
+               }
+               else
+                   uiAoeTimer -= diff;
+
+               if(uiPlagueStrikeTimer <= diff)
+               {
+                   DoCast(me->GetVictim(), SPELL_UNHOLY_PLAGUE_STRIKE);
+                   uiPlagueStrikeTimer = urand(5000, 8000);
+               }
+               else
+                   uiPlagueStrikeTimer -= diff;
+
+               if(uiStangulateTimer <= diff)
+               {
+                   DoCast(me->GetVictim(), SPELL_UNHOLY_STANGULATE, true);
+                   uiStangulateTimer = 15000;
+               }
+               else
+                   uiStangulateTimer -= diff;
+
+               if(uiDeathStrikeTimer <= diff)
+               {
+                   DoCast(me->GetVictim(), SPELL_UNHOLY_DEATH_STRIKE);
+                   uiDeathStrikeTimer = urand(9000, 12000);
+               }
+               else
+                   uiDeathStrikeTimer -= diff;
+
+               if(uiArmyOfTheDeadTimer <= diff)
+               {
+                   DoCast(me, SPELL_UNHOLY_ARMY, true);
+                   uiArmyOfTheDeadTimer = 30000;
+               }
+               else
+                   uiArmyOfTheDeadTimer -= diff;
+               DoMeleeAttackIfReady();
+           }
+
+           void JustSummoned(Creature * summoned)
+           {
+               summons.Summon(summoned);
+           }
+
+          private:
+              Creature * guin;
+              Creature * twin;
+              SummonList summons;
+       };
+
+       CreatureAI * GetAI(Creature * pCreature) const
+       {
+           return new npc_dm_main_unholyAI(pCreature);
+       }
+};
+
+class npc_dm_unholy_twin : public CreatureScript
+{
+   public:
+       npc_dm_unholy_twin() : CreatureScript("npc_dm_unholy_twin") { }
+
+       struct npc_dm_unholy_twinAI : public ScriptedAI
+       {
+           npc_dm_unholy_twinAI(Creature * c) : ScriptedAI(c) { }
+
+           uint32 uiCinematic;
+           uint32 uiAoeTimer;
+           uint32 uiPlagueStrikeTimer;
+           uint32 uiStangulateTimer;
+           uint32 uiDeathStrikeTimer;
+           uint32 uiArmyOfTheDeadTimer;
+           int cinematicPassed;
+           bool boneArmor;
+
+           void Reset()
+           {
+               uiCinematic = 6000;
+               boneArmor = true;
+               cinematicPassed = 0;
+               me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_NOT_SELECTABLE);
+               me->SetReactState(REACT_PASSIVE);
+               me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID+0, 51393);
+           }
+
+           void OnCombatStart(Unit * /* who */)
+           {
+               me->AddAura(SPELL_UNHOLY_BONE_SHIELD, me);
+               uiAoeTimer = 25000;
+               uiPlagueStrikeTimer = urand(5000, 8000);
+               uiDeathStrikeTimer = urand(9000, 12000);
+               uiStangulateTimer = 15000;
+               uiArmyOfTheDeadTimer = 30000;
+           }
+
+           void KilledUnit(Unit * who)
+           {
+               if(who && who->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               DoEndBattle(me);
+           }
+
+           void UpdateAI(const uint32 diff)
+           {
+               if(uiCinematic <= diff)
+               {
+                   switch(cinematicPassed)
+                   {
+                       case 0:
+                           me->Say("I believe it wants to fight us.", LANG_UNIVERSAL, 0);
+                           cinematicPassed = 1;
+                           uiCinematic = 7000;
+                           break;
+
+                       case 1:
+                           me->Say("Yes. So it seems.", LANG_UNIVERSAL, 0);
+                           cinematicPassed = 2;
+                           uiCinematic = 6000;
+                           break;
+
+                       case 2:
+                           me->Say("What? FIGHT?", LANG_UNIVERSAL, 0);
+                           cinematicPassed = 3;
+                           uiCinematic = 3000;
+                           break;
+
+                       case 3:
+                           me->Yell("GUIN! NO!", LANG_UNIVERSAL, 0);
+                           cinematicPassed = 4;
+                           break;
+                   }
+               }
+               else
+                   uiCinematic -= diff;
+
+               if(!UpdateVictim())
+                   return;
+
+               if(HealthBelowPct(25) && boneArmor)
+               {
+                   me->AddAura(SPELL_UNHOLY_BONE_SHIELD, me);
+                   boneArmor = false;
+               }
+
+               if(uiAoeTimer <= diff)
+               {
+                   me->CastSpell(me->GetVictim(), SPELL_UNHOLY_AOE, true);
+                   uiAoeTimer = 25000;
+               }
+               else
+                   uiAoeTimer -= diff;
+
+               if(uiPlagueStrikeTimer <= diff)
+               {
+                   DoCast(me->GetVictim(), SPELL_UNHOLY_PLAGUE_STRIKE);
+                   uiPlagueStrikeTimer = urand(5000, 8000);
+               }
+               else
+                   uiPlagueStrikeTimer -= diff;
+
+               if(uiStangulateTimer <= diff)
+               {
+                   DoCast(me->GetVictim(), SPELL_UNHOLY_STANGULATE, true);
+                   uiStangulateTimer = 15000;
+               }
+               else
+                   uiStangulateTimer -= diff;
+
+               if(uiDeathStrikeTimer <= diff)
+               {
+                   DoCast(me->GetVictim(), SPELL_UNHOLY_DEATH_STRIKE);
+                   uiDeathStrikeTimer = urand(9000, 12000);
+               }
+               else
+                   uiDeathStrikeTimer -= diff;
+
+               if(uiArmyOfTheDeadTimer <= diff)
+               {
+                   DoCast(me, SPELL_UNHOLY_ARMY, true);
+                   uiArmyOfTheDeadTimer = 30000;
+               }
+               else
+                   uiArmyOfTheDeadTimer -= diff;
+               DoMeleeAttackIfReady();
+           }
+
+       };
+
+       CreatureAI * GetAI(Creature * pCreature) const
+       {
+           return new npc_dm_unholy_twinAI(pCreature);
+       }
+};
+
+class npc_dm_unholy_pet : public CreatureScript
+{
+   public:
+       npc_dm_unholy_pet() : CreatureScript("npc_dm_unholy_pet") { }
+
+       struct npc_dm_unholy_petAI : public ScriptedAI
+       {
+           npc_dm_unholy_petAI(Creature * c) : ScriptedAI(c) { }
+
+           uint32 uiCinematicTimer;
+           uint32 uiPhaseChangeTimer;
+           uint32 uiEnrageTimer;
+           int phase;
+           int cinematicPassed;
+
+           void Reset()
+           {
+               uiCinematicTimer = 16000;
+               uiPhaseChangeTimer = 1000;
+               uiEnrageTimer = 5000;
+               phase = 1;
+               cinematicPassed = 0;
+               me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_NOT_SELECTABLE);
+               me->SetReactState(REACT_PASSIVE);
+           }
+
+           void KilledUnit(Unit * who)
+           {
+               if(who && who->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               DoEndBattle(me);
+           }
+
+           void UpdateAI(const uint32 diff)
+           {
+               if(uiCinematicTimer <= diff)
+               {
+                   switch(cinematicPassed)
+                   {
+                       case 0:
+                           me->Say("Why can't we fight masters?", LANG_UNIVERSAL, 0);
+                           cinematicPassed = 1;
+                           uiCinematicTimer = 5000;
+                           break;
+
+                       case 1:
+                           me->Yell("Well, I'm hungry!", LANG_UNIVERSAL, me);
+                           me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_NOT_SELECTABLE);
+                           me->SetReactState(REACT_AGGRESSIVE);
+                           if(Player * player = me->SelectNearestPlayer(500.0f))
+                               if(player && player->GetGUID() == m_PlayerGUID)
+                               {
+                                   me->Attack(player, true);
+                                   me->GetMotionMaster()->MoveChase(player);
+                               }
+                           cinematicPassed = 2;
+                           break;
+                   }
+               }
+               else
+                   uiCinematicTimer -= diff;
+
+               if(!UpdateVictim())
+                   return;
+
+               if(uiPhaseChangeTimer <= diff)
+               {
+                   switch(phase)
+                   {
+                       case 1:
+                           break;
+
+                       case 2:
+                           break;
+
+                       case 3:
+                           break;
+
+                       case 4:
+                           break;
+                   }
+                   if(HealthBelowPct(85) && phase == 1)
+                   {
+                       DoIncreaseHealth(me, 2.0f, phase, 2);
+                   }
+                   else if(HealthBelowPct(65) && phase == 2)
+                   {
+                       DoIncreaseHealth(me, 2.5f, phase, 3);
+                   }
+                   else if(HealthBelowPct(35) && phase == 3)
+                   {
+                       DoIncreaseHealth(me, 3.0f, phase, 4);
+                   }
+                   else if(HealthBelowPct(15) && phase == 4)
+                   {
+                       me->Yell("HUNGER!", LANG_UNIVERSAL, me);
+                       DoIncreaseHealth(me, 3.5f, phase, 5);
+                   }
+               }
+               else
+                   uiPhaseChangeTimer -= diff;
+
+               if(uiEnrageTimer <= diff)
+               {
+                   DoCast(SPELL_ENRAGE);
+                   uiEnrageTimer = 5000;
+               }
+               else
+                   uiEnrageTimer -= diff;
+               DoMeleeAttackIfReady();
+           }
+       };
+
+       CreatureAI * GetAI(Creature * pCreature) const
+       {
+           return new npc_dm_unholy_petAI(pCreature);
+       }
+};
+
+class npc_army_ghoul : public CreatureScript
+{
+   public:
+       npc_army_ghoul() : CreatureScript("npc_army_ghoul") { }
+
+       struct npc_army_ghoulAI : public ScriptedAI
+       {
+           npc_army_ghoulAI(Creature * c) : ScriptedAI(c) { }
+
+           void KilledUnit(Unit * who)
+           {
+               if(who && who->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               DoEndBattle(me);
+           }
+       };
+       CreatureAI * GetAI(Creature * pCreature) const
+       {
+           return new npc_army_ghoulAI(pCreature);
+       }
+};
+
+class npc_dm_rider_guardian : public CreatureScript
+{
+   public:
+       npc_dm_rider_guardian() : CreatureScript("npc_dm_rider_guardian") { }
+
+       struct npc_dm_rider_guardianAI : public ScriptedAI
+       {
+           npc_dm_rider_guardianAI(Creature * c) : ScriptedAI(c), summons(me) { }
+
+           uint32 uiShieldTimer;
+           uint32 uiHealingBoltTimer;
+           uint32 uiRenewTimer;
+           uint32 uiGreaterHealTimer;
+           uint32 uiHealingBoltWaitTimer;
+           bool checkBrutes;
+           bool giveUp;
+           bool InHealingBolt;
+
+           void Reset()
+           {
+               uiShieldTimer = 25000;
+               uiHealingBoltTimer = urand(10000, 14000);
+               uiRenewTimer = 5000;
+               uiGreaterHealTimer = 8000;
+               me->SetReactState(REACT_PASSIVE);
+               me->CastSpell(me, SPELL_RIDERS_SHIELD, true);
+               me->CastSpell(me, SPELL_RIDERS_STAM_BUFF, true);
+               me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID+0, 51453);
+               checkBrutes = false;
+               giveUp = false;
+               InHealingBolt = false;
+               summons.DespawnAll();
+               brute = me->SummonCreature(waveList[17], m_WaveSpawns[0].m_positionX, m_WaveSpawns[0].m_positionY+3, m_WaveSpawns[0].m_positionZ, m_WaveSpawns[0].m_orientation, TEMPSUMMON_MANUAL_DESPAWN, 0);
+               brute2 = me->SummonCreature(waveList[18], m_WaveSpawns[0].m_positionX, m_WaveSpawns[0].m_positionY-3, m_WaveSpawns[0].m_positionZ, m_WaveSpawns[0].m_orientation, TEMPSUMMON_MANUAL_DESPAWN, 0);
+           }
+
+           void KilledUnit(Unit * who)
+           {
+               if(who && who->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               DoEndBattle(me, summons);
+           }
+
+           void JustSummoned(Creature * summoned)
+           {
+               summons.Summon(summoned);
+           }
+
+           void UpdateAI(const uint32 diff)
+           {
+               if(!isBattleActive)
+               {
+                   summons.DespawnAll();
+                   brute = 0;
+                   brute2 = 0;
+                   me->DespawnOrUnsummon(1);
+                   return;
+               }
+
+               if(HealthBelowPct(25) && !giveUp)
+               {
+                   me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_NOT_SELECTABLE);
+                   me->Yell("I.. I GIVE UP!", LANG_UNIVERSAL, me);
+                   me->SetHealth(me->GetMaxHealth());
+                   checkBrutes = true;
+                   giveUp = true;
+               }
+
+               if(checkBrutes && giveUp)
+               {
+                   if(brute && brute->isDead() && brute2 && brute2->isDead())
+                   {
+                       if(Player * player = me->SelectNearestPlayer(200.0f))
+                           if(player && player->GetGUID() == m_PlayerGUID)
+                               me->PlayDirectSound(SOUND_WAVE_COMPLETE, player);
+                       summons.DespawnAll();
+                       me->DespawnOrUnsummon(1);
+                       isWaveBossDead = 6;
+                   }
+                   return;
+               }
+
+               if(uiShieldTimer <= diff && !InHealingBolt)
+               {
+                   int target = urand(0, 2);
+                   switch(target)
+                   {
+                      case 0:
+                          if(brute)
+                              DoCast(brute, SPELL_RIDERS_SHIELD);
+                          break;
+
+                      case 1:
+                          if(brute2)
+                              DoCast(brute2, SPELL_RIDERS_SHIELD);
+                          break;
+
+                      case 2:
+                          DoCast(me, SPELL_RIDERS_SHIELD);
+                          break;
+                   }
+                   uiShieldTimer = 16000;
+               }
+               else
+                   uiShieldTimer -= diff;
+
+               if(uiHealingBoltTimer <= diff)
+               {
+                   int target = urand(0, 1);
+                   switch(target)
+                   {
+                      case 0:
+                          if(brute && brute->GetHealthPct() <= 85)
+                              me->CastSpell(brute, SPELL_RIDERS_HEALING_BOLT, true);
+                          break;
+
+                      case 1:
+                          if(brute2 && brute2->GetHealthPct() <= 65)
+                              me->CastSpell(brute2, SPELL_RIDERS_HEALING_BOLT, true);
+                          break;
+                   }
+                   InHealingBolt = true;
+                   uiHealingBoltWaitTimer = 3000;
+                   uiHealingBoltTimer = urand(10000, 14000);
+               }
+               else
+                   uiHealingBoltTimer -= diff;
+
+               if(InHealingBolt)
+               {
+                   if(uiHealingBoltWaitTimer <= diff)
+                   {
+                       InHealingBolt = false;
+                   }
+                   else
+                       uiHealingBoltWaitTimer -= diff;
+               }
+
+               if(uiRenewTimer <= diff && !InHealingBolt)
+               {
+                   int target = urand(0, 2);
+                   switch(target)
+                   {
+                      case 0:
+                          if(brute)
+                              DoCast(brute, SPELL_RIDERS_RENEW);
+                          break;
+
+                      case 1:
+                          if(brute2)
+                              DoCast(brute2, SPELL_RIDERS_RENEW);
+                          break;
+
+                      case 2:
+                          if(HealthBelowPct(80))
+                              DoCast(me, SPELL_RIDERS_RENEW);
+                          break;
+                   }
+                   uiRenewTimer = 5000;
+               }
+               else
+                   uiRenewTimer -= diff;
+
+               if(uiGreaterHealTimer <= diff && !InHealingBolt)
+               {
+                   int target = urand(0, 2);
+                   switch(target)
+                   {
+                      case 0:
+                          if(brute && brute->GetHealthPct() <= 30)
+                              me->CastSpell(brute, SPELL_RIDERS_GREATER_HEAL, true);
+                          break;
+
+                      case 1:
+                          if(brute2 && brute2->GetHealthPct() <= 20)
+                              me->CastSpell(brute2, SPELL_RIDERS_GREATER_HEAL, true);
+                          break;
+
+                      case 2:
+                          if(HealthBelowPct(40))
+                              me->CastSpell(me, SPELL_RIDERS_GREATER_HEAL, true);
+                          break;
+                   }
+                   uiGreaterHealTimer = 6000;
+               }
+               else
+                   uiGreaterHealTimer -= diff;
+           }
+          private:
+              Creature * brute;
+              Creature * brute2;
+              SummonList summons;
+       };
+
+       CreatureAI * GetAI(Creature * pCreature) const
+       {
+           return new npc_dm_rider_guardianAI(pCreature);
+       }
+};
+
+class npc_dm_rider_brute : public CreatureScript
+{
+   public:
+       npc_dm_rider_brute() : CreatureScript("npc_dm_rider_brute") { }
+
+       struct npc_dm_rider_bruteAI : public ScriptedAI
+       {
+           npc_dm_rider_bruteAI(Creature * c) : ScriptedAI(c) { }
+
+           uint32 uiLightningTimer;
+           uint32 uiChainLightningTimer;
+           uint32 uiMoonfireTimer;
+           uint32 uiLightningStormTimer;
+           uint32 uiLightningWaitTimer;
+           bool InLightningChannel;
+
+           void Reset()
+           {
+               uiLightningTimer = 13000;
+               uiChainLightningTimer = urand(6000, 9000);
+               uiMoonfireTimer = 5000;
+               uiLightningStormTimer = urand(20000, 26000);
+               InLightningChannel = false;
+               me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID+0, 51517);
+               me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID+1, 51447);
+           }
+
+           void KilledUnit(Unit * who)
+           {
+               if(who && who->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               DoEndBattle(me);
+           }
+
+           void UpdateAI(const uint32 diff)
+           {
+               if(!UpdateVictim())
+                   return;
+
+               if(!isBattleActive)
+               {
+                   me->DespawnOrUnsummon(1);
+                   return;
+               }
+
+               if(uiLightningTimer <= diff)
+               {
+                   if(!InLightningChannel)
+                       DoCast(me->GetVictim(), SPELL_RIDERS_LIGHTNING);
+                   uiLightningTimer = 13000;
+               }
+               else
+                   uiLightningTimer -= diff;
+
+               if(uiChainLightningTimer <= diff)
+               {
+                   if(!InLightningChannel)
+                       DoCast(me->GetVictim(), SPELL_RIDERS_CHAIN_LIGHTNING, true);
+                   uiChainLightningTimer = urand(6000, 9000);
+               }
+               else
+                   uiChainLightningTimer -= diff;
+
+               if(uiMoonfireTimer <= diff)
+               {
+                   if(!InLightningChannel)
+                       DoCast(me->GetVictim(), SPELL_RIDERS_MOONFIRE);
+                   uiMoonfireTimer = 5000;
+               }
+               else
+                   uiMoonfireTimer -= diff;
+
+               if(uiLightningStormTimer <= diff)
+               {
+                   if(!InLightningChannel)
+                   {
+                       me->CastSpell(me->GetVictim(), SPELL_RIDERS_STORM, true);
+                       InLightningChannel = true;
+                       uiLightningWaitTimer = 10000;
+                   }
+                   uiLightningStormTimer = urand(20000, 26000);
+               }
+               else
+                   uiLightningStormTimer -= diff;
+
+               if(InLightningChannel)
+               {
+                   if(uiLightningWaitTimer <= diff)
+                   {
+                       InLightningChannel = false;
+                   }
+                   else
+                       uiLightningWaitTimer -= diff;
+               }
+
+               if(!InLightningChannel)
+                   DoMeleeAttackIfReady();
+           }
+       };
+
+       CreatureAI * GetAI(Creature * pCreature) const
+       {
+           return new npc_dm_rider_bruteAI(pCreature);
+       }
+};
+
+class npc_dm_dragon_final : public CreatureScript
+{
+   public:
+       npc_dm_dragon_final() : CreatureScript("npc_dm_dragon_final") { }
+
+       struct npc_dm_dragon_finalAI : public ScriptedAI
+       {
+           npc_dm_dragon_finalAI(Creature * c) : ScriptedAI(c), summons(me) { }
+
+           uint32 uiBerserkTimer;
+           uint32 uiBreathTimer;
+           uint32 uiTailWhipTimer;
+           uint32 uiClawTimer;
+           uint32 uiFlameStrikeTimer;
+           uint32 uiFlightTimer;
+           uint32 uiFlightWaitTimer;
+           uint32 uiLandTimer;
+
+           uint32 m_Phase;
+           int  FlameStrikeData;
+           bool IsInFlight;
+           bool FireShield;
+           bool canLand;
+
+           void Reset()
+           {
+           if (!IsCombatMovementAllowed())
+               SetCombatMovement(true);
+
+               uiFlightTimer = 10000; // 10s
+               uiClawTimer = urand(3000, 5000);
+               uiTailWhipTimer = urand(12000, 16000);
+               uiBreathTimer = urand(18000, 22000);
+
+               FlameStrikeData = 0;
+
+               summons.DespawnAll();
+               IsInFlight = false;
+               FireShield = true;
+               canLand = false;
+           }
+
+           void EnterCombat(Unit * /* who */)
+           {
+               m_Phase = PHASE_START_COMBAT;
+               uiBerserkTimer = 420000; // 7 Mins
+           }
+
+           void KilledUnit(Unit * who)
+           {
+               if(who && who->GetTypeId() != TYPEID_PLAYER)
+                   return;
+               DoEndBattle(me, summons);
+           }
+
+           void JustDied(Unit * killer)
+           {
+               if(killer && killer->GetTypeId() != TYPEID_PLAYER &&
+                   killer->GetGUID() != m_PlayerGUID)
+                   return;
+               me->PlayDirectSound(SOUND_WAVE_COMPLETE, killer->ToPlayer());
+               m_Phase = PHASE_END;
+               isWaveBossDead = 7;
+           }
+
+           void MovementInform(uint32 type, uint32 id)
+           {
+               if(type == POINT_MOTION_TYPE)
+               {
+                   switch(id)
+                   {
+                       case 1:
+                           //me->SetFacingTo(sMoveData[0].o);
+                           //me->SetLevitate(true);
+                           break;
+                   }
+               }
+           }
+
+           void JustSummoned(Creature * summoned)
+           {
+               summons.Summon(summoned);
+           }
+
+           void UpdateAI(const uint32 diff)
+           {
+               if(!UpdateVictim() || m_Phase == PHASE_END)
+                   return;
+
+               if(!isBattleActive)
+               {
+                   summons.DespawnAll();
+                   m_Phase = PHASE_END;
+                   me->DespawnOrUnsummon(1);
+                   return;
+               }
+
+               if(m_Phase == PHASE_START_COMBAT)
+               {
+                   if(HealthBelowPct(15) && FireShield) // Doesn't matter if you're flying
+                   {
+                       DoCast(me, SPELL_DRAGON_FIRE_SHIELD, true);
+                       FireShield = false;
+                   }
+
+                   if(uiClawTimer <= diff)
+                   {
+                       if(!IsInFlight)
+                           DoCast(me->GetVictim(), SPELL_DRAGON_CLAW);
+                       uiClawTimer = urand(3000, 5000);
+                   }
+                   else
+                       uiClawTimer -= diff;
+
+                   if(uiBreathTimer <= diff)
+                   {
+                       if(!IsInFlight)
+                           me->CastSpell(me->GetVictim(), SPELL_DRAGON_BREATH, true);
+                       uiBreathTimer = urand(18000, 24000);
+                   }
+                   else
+                       uiBreathTimer -= diff;
+
+                   if(uiTailWhipTimer <= diff)
+                   {
+                       if(!IsInFlight)
+                           DoCastAOE(SPELL_DRAGON_TAIL_WHIP, false);
+                       uiTailWhipTimer = urand(12000, 16000);
+                   }
+                   else
+                       uiTailWhipTimer -= diff;
+
+                   if(uiBerserkTimer <= diff)
+                   {
+                       DoCast(me, SPELL_DRAGON_BERSERK);
+                       uiBerserkTimer = 420000;
+                   }
+                   else
+                       uiBerserkTimer -= diff;
+
+                   if(uiFlightTimer <= diff && !IsInFlight)
+                   {
+                       //me->SetFlying(true);
+                       me->SetSpeed(MOVE_FLIGHT, 1.3f);
+                       me->GetMotionMaster()->MovePoint(1, -3786.241943f, 1096.538452f, 153.903366f);
+                       FlameStrikeData = 0;
+                       uiFlameStrikeTimer = 6000;
+                       uiFlightWaitTimer = 30000;
+                       IsInFlight = true;
+                       uiFlightTimer = 50000;
+                   }
+                   else
+                       uiFlightTimer -= diff;
+
+                   if(IsInFlight)
+                   {
+                       if(uiFlameStrikeTimer <= diff)
+                       {
+                           switch(FlameStrikeData)
+                           {
+                              case 0:
+                                  me->TextEmote("The Arena Dragon has a lot of fire inside!", 0, true);
+                                  groundTarget = me->SummonGameObject(sMoveData[0].gobject, me->GetVictim()->GetPositionX()-3, me->GetVictim()->GetPositionY()+6, me->GetVictim()->GetPositionZ(),
+                                  me->GetOrientation(), QuaternionData(), 1);
+                                  uiFlameStrikeTimer = 2000;
+                                  FlameStrikeData = 1;
+                                  break;
+
+                              case 1:
+                                  trigger = me->SummonCreature(NPC_DRAGON_BOSS_TRIGGER, groundTarget->GetPositionX(), groundTarget->GetPositionY(), groundTarget->GetPositionZ(), 0.0f,
+                                      TEMPSUMMON_TIMED_DESPAWN, 3000);
+                                  me->CastSpell(trigger, sMoveData[0].spellId, true);
+                                  uiFlameStrikeTimer = 2000;
+                                  FlameStrikeData = 2;
+                                  break;
+
+                              case 2:
+                                  if(groundTarget)
+                                      groundTarget->Delete();
+                                  me->TextEmote("The Arena Dragon has a lot of fire inside!", 0, true);
+                                  groundTarget = me->SummonGameObject(sMoveData[0].gobject, me->GetVictim()->GetPositionX()-3, me->GetVictim()->GetPositionY()-6, me->GetVictim()->GetPositionZ(),
+                                      me->GetOrientation(), QuaternionData(), 1);
+                                  uiFlameStrikeTimer = 2000;
+                                  FlameStrikeData = 3;
+                                  break;
+
+                              case 3:
+                                  trigger = me->SummonCreature(NPC_DRAGON_BOSS_TRIGGER, groundTarget->GetPositionX(), groundTarget->GetPositionY(), groundTarget->GetPositionZ(), 0.0f,
+                                      TEMPSUMMON_TIMED_DESPAWN, 3000);
+                                  me->CastSpell(trigger, sMoveData[0].spellId, true);
+                                  uiFlameStrikeTimer = 2000;
+                                  FlameStrikeData = 4;
+                                  break;
+
+                              case 4:
+                                  if(groundTarget)
+                                      groundTarget->Delete();
+                                  me->TextEmote("The Arena Dragon has a lot of fire inside!", 0, true);
+                                  groundTarget = me->SummonGameObject(sMoveData[0].gobject, me->GetVictim()->GetPositionX()-3, me->GetVictim()->GetPositionY()-6, me->GetVictim()->GetPositionZ(),
+                                      me->GetOrientation(), QuaternionData(), 1);
+                                  uiFlameStrikeTimer = 2000;
+                                  FlameStrikeData = 5;
+                                  break;
+
+                              case 5:
+                                  trigger = me->SummonCreature(NPC_DRAGON_BOSS_TRIGGER, groundTarget->GetPositionX(), groundTarget->GetPositionY(), groundTarget->GetPositionZ(), 0.0f,
+                                      TEMPSUMMON_TIMED_DESPAWN, 3000);
+                                  me->CastSpell(trigger, sMoveData[0].spellId, true);
+                                  uiFlameStrikeTimer = 2000;
+                                  FlameStrikeData = 6;
+                                  break;
+
+                              case 6:
+                                  if(groundTarget)
+                                      groundTarget->Delete();
+                                  me->TextEmote("The Arena Dragon has a lot of fire inside!", 0, true);
+                                  groundTarget = me->SummonGameObject(sMoveData[0].gobject, me->GetVictim()->GetPositionX()-3, me->GetVictim()->GetPositionY()+6, me->GetVictim()->GetPositionZ(),
+                                      me->GetOrientation(), QuaternionData(), 1);
+                                  uiFlameStrikeTimer = 2000;
+                                  FlameStrikeData = 7;
+                                  break;
+
+                              case 7:
+                                  trigger = me->SummonCreature(NPC_DRAGON_BOSS_TRIGGER, groundTarget->GetPositionX(), groundTarget->GetPositionY(), groundTarget->GetPositionZ(), 0.0f,
+                                      TEMPSUMMON_TIMED_DESPAWN, 3000);
+                                  me->CastSpell(trigger, sMoveData[0].spellId, true);
+                                  uiFlameStrikeTimer = 2000;
+                                  FlameStrikeData = 8;
+                                  break;
+
+                              case 8:
+                                  if(groundTarget)
+                                      groundTarget->Delete();
+                                  me->TextEmote("The Arena Dragon has a lot of fire inside!", 0, true);
+                                  groundTarget = me->SummonGameObject(sMoveData[0].gobject, me->GetVictim()->GetPositionX()-3, me->GetVictim()->GetPositionY()+6, me->GetVictim()->GetPositionZ(),
+                                      me->GetOrientation(), QuaternionData(), 1);
+                                  uiFlameStrikeTimer = 2000;
+                                  FlameStrikeData = 9;
+                                  break;
+
+                              case 9:
+                                  trigger = me->SummonCreature(NPC_DRAGON_BOSS_TRIGGER, groundTarget->GetPositionX(), groundTarget->GetPositionY(), groundTarget->GetPositionZ(), 0.0f,
+                                      TEMPSUMMON_TIMED_DESPAWN, 3000);
+                                  me->CastSpell(trigger, sMoveData[0].spellId, true);
+                                  uiFlameStrikeTimer = 1000;
+                                  FlameStrikeData = 10;
+                                  break;
+
+                              case 10:
+                                  if(groundTarget)
+                                      groundTarget->Delete();
+                                  FlameStrikeData = 11;
+                                  break;
+                           }
+                       }
+                       else
+                           uiFlameStrikeTimer -= diff;
+
+                       if(uiFlightWaitTimer <= diff && !canLand)
+                       {
+                           me->GetMotionMaster()->MovePoint(2, me->GetHomePosition()); // Back Home
+                           canLand = true;
+                           uiLandTimer = 5000;
+                       }
+                       else
+                           uiFlightWaitTimer -= diff;
+
+                       if(uiLandTimer <= diff && canLand)
+                       {
+                           //me->SetFlying(false);
+                           //me->SetLevitate(false);
+                           SetCombatMovement(true);
+                           me->GetMotionMaster()->Clear(false);
+                           me->GetMotionMaster()->MoveChase(me->GetVictim());
+                           IsInFlight = false;
+                           canLand = false;
+                       }
+                       else
+                           uiLandTimer -= diff;
+                   }
+               }
+              if(!IsInFlight)
+                  DoMeleeAttackIfReady();
+           }
+           private:
+               GameObject * groundTarget;
+               Creature * trigger;
+               SummonList summons;
+       };
+
+       CreatureAI * GetAI(Creature * pCreature) const
+       {
+           return new npc_dm_dragon_finalAI(pCreature);
+       }
+};
+
+class remove_non_battle_player : public PlayerScript
+{
+   public:
+       remove_non_battle_player() : PlayerScript("remove_non_battle_player") { }
+
+       void OnUpdateZone(Player * player, uint32 zone, uint32 area)
+       {
+           if(m_PlayerGUID == 0)
+               return;
+
+           if(player->GetZoneId() != DIRE_MAUL_ZONE && player->GetAreaId() != DIRE_MAUL_AREA && player->GetGUID() == m_PlayerGUID)
+           {
+               inZone = false;
+               return;
+           }
+
+           if(player->GetAreaId() != DIRE_MAUL_AREA || player->GetSession()->GetSecurity() > 1)
+               return;
+
+           if(isBattleActive && player->GetGUID() != m_PlayerGUID)
+           {
+               player->TeleportTo(player->GetStartPosition().GetMapId(), player->GetStartPosition().GetPositionX(), player->GetStartPosition().GetPositionY(),
+                  player->GetStartPosition().GetPositionZ(), player->GetStartPosition().GetOrientation());
+               ChatHandler(player->GetSession()).PSendSysMessage("You cannot be in the Dire Maul Arena while the event is going on!");
+           }
+       }
+
+       void OnLogout(Player * player)
+       {
+           if(m_PlayerGUID == 0)
+               return;
+
+           if(player->GetGUID() == m_PlayerGUID)
+               hasLogged = true;
+       }
+};
+
+void AddSC_arena_link_battle()
+{
+    /* Npc Classes */
+    new npc_dire_arena_commander();
+    new npc_dire_maul_rb_guard();
+    new npc_red_blood_mini();
+    new npc_dm_wave_trigger();
+    new npc_dm_wave_spawns();
+    new npc_dm_hank_the_tank();
+    new npc_dm_field_medic();
+    new npc_dm_main_rogue();
+    new npc_dm_rogue_initiate();
+    new npc_dm_main_unholy();
+    new npc_dm_unholy_twin();
+    new npc_dm_unholy_pet();
+    new npc_army_ghoul();
+    new npc_dm_rider_guardian();
+    new npc_dm_rider_brute();
+    new npc_dm_dragon_final();
+    new npc_dm_wave_portals();
+    /* Player Classes */
+    new remove_non_battle_player();
+}
diff --git a/src/server/scripts/Custom/npcs_dm_battle.h b/src/server/scripts/Custom/npcs_dm_battle.h
new file mode 100644
index 0000000..698e183
--- /dev/null
+++ b/src/server/scripts/Custom/npcs_dm_battle.h
@@ -0,0 +1,369 @@
+/**********************************************************
+**********************************************************
+ *                      Title:                          *
+  *            NPC Arena Battle(Dire Maul)             *
+   *                                                  *
+    *             Idea by: QQrofl                    *
+     *            Sub-Ideas by: Foereaper           *
+      *            Scripted by: QQrofl             *
+       *              Fondled by: Faded           *
+        *    Mental Support by: Foereaper        *
+         *        Updated by: LordPsyan         *
+          *                                    *
+*##########*##################################*##########*
+*        MAIN SPAWN                                      *
+*    Arena Commander:  Entry: 80700                      *
+*    -3815.866699f, 1102.770874f, 132.355194f, 6.182988f *
+*########################################################*/
+#include "Chat.h"
+#include "ScriptPCH.h"
+#include "World.h"
+
+using namespace std;
+
+/* Player */
+ObjectGuid m_PlayerGUID;
+string playerName;
+/* Is Active */
+bool isBattleActive = false;
+bool hasLogged = false;
+bool inZone = true;
+/* Is Bosses Dead */
+int isWaveBossDead = 0;
+
+#define MSG_FIGHT_COMPUTER "I would like to fight!"
+
+enum Events
+{
+    EVENT_NONE,
+    EVENT_CHECK_ACTIVITY, // Check Activity of the battle : if true or false ? can start?
+    EVENT_CHECK_WAVES, // Checks the waves so it can move on to the next event, if it is allowed
+    EVENT_CHECK_PLAYER,
+    EVENT_FIRST_WAVE,
+    EVENT_FIRST_WAVE_TREAT,
+    EVENT_FIRST_WAVE_ELITE,
+    EVENT_SECOND_WAVE,
+    EVENT_SECOND_WAVE_TREAT,
+    EVENT_SECOND_WAVE_ELITE,
+    EVENT_FINAL_WAVE_BOSS,
+    EVENT_COMPLETED_WAVES,
+};
+
+enum bPhases
+{
+    /* Final Boss Phases */
+    PHASE_START_COMBAT,
+    PHASE_END,
+};
+
+enum SpellIds
+{
+    /* First Wave Spells */
+    /* Red Blood Guard */
+    SPELL_BERSERKER_CHARGE = 38907,
+    SPELL_MORTAL_STRIKE = 68783,
+    SPELL_DEEP_WOUNDS = 23256,
+    /* First Wave Elite Spells */
+    /* `- Spore Healer */
+    SPELL_HEAL_REGROWTH = 48443, //heal+H.O.T.
+    SPELL_HEAL_NORMAL = 48378, //heal normal
+    SPELL_HEAL_REJUV = 48441, //H.O.T.
+    SPELL_HEAL_AURA_HOTS = 38299, // Aura hots
+    SPELL_FLASH_HEAL = 48071,
+    SPELL_POWER_WORD_SHIELD = 20697, // Absorbs a ton of damage
+    SPELL_HEAL_LIFEBLOOM = 67958,
+    /* `- Hank the Tank */
+    SPELL_BATTLE_STANCE = 2487, //warrior bstance
+    SPELL_SHOUT_BUFF = 47436,    //attk pwr self buff
+    SPELL_TANK_CHARGE = 11578,    //warrior charge
+    SPELL_GROUND_STOMP = 47502, //thunderclap
+    SPELL_EXECUTE = 47471,        //normal strike
+    SPELL_TANK_STRIKE = 47450,    //normal strike
+    SPELL_INCREASE_BLOCK_VALUE = 67515, // Increases block value
+    SPELL_SHIELD_BLOCK = 69580, // Blocks attacks
+    SPELL_INCREASE_DEFENSE_RATING = 60343, // Increases Defense by 180+
+    SPELL_INCREASE_DODGE_RATING = 18062, // Increase dodge by 96
+    SPELL_REND = 47465, // Rends the target ~Bleeds
+    SPELL_SHIELD_BASH = 47488, // Bashes the target with a shield
+    /* Second Wave Spells */
+    SPELL_ROGUE_STEALTH = 1784,
+    SPELL_ROGUE_CHEAP_SHOT = 1833, //in stealth only
+    SPELL_ROGUE_STRIKE = 48660,
+    SPELL_ROGUE_FINISHER = 48668,
+    SPELL_ROGUE_VANISH = 26889, //idea here is to make the sidekicks(and main?) vanish in/out of the fight
+    SPELL_ROGUE_KICK = 27814,
+    SPELL_ROGUE_BACKSTAB = 52540,
+    SPELL_ROGUE_RUPTURE = 48672,
+    SPELL_ROGUE_KIDNEY_SHOT = 41389,
+    /* Second Wave Treat Spells */
+    SPELL_UNHOLY_BONE_SHIELD = 49222,
+    SPELL_UNHOLY_AOE = 49938,
+    SPELL_UNHOLY_PLAGUE_STRIKE = 49921,
+    SPELL_UNHOLY_STANGULATE = 47476,
+    SPELL_UNHOLY_DEATH_STRIKE = 49924,
+    SPELL_UNHOLY_ARMY = 42650, // <- should happen with both NPC's simultaneously
+    SPELL_ENRAGE = 59707,
+    /* Second Wave Elite Spells */
+    /*    `- Rider Brutes    */
+    SPELL_RIDERS_LIGHTNING = 59159, // aoe
+    SPELL_RIDERS_CHAIN_LIGHTNING = 49269, // aoe
+    SPELL_RIDERS_MOONFIRE = 48463,
+    SPELL_RIDERS_STORM = 48467, // aoe
+    /*    `- Rider Healer    */
+    SPELL_RIDERS_STAM_BUFF = 48161, // fortitude buff
+    SPELL_RIDERS_SHIELD = 48066, // absorbs damage
+    SPELL_RIDERS_HEALING_BOLT = 66097,
+    SPELL_RIDERS_RENEW = 48068,
+    SPELL_RIDERS_GREATER_HEAL = 48063,
+    /* Final Wave Boss Spells */
+    SPELL_DRAGON_FIRE_SHIELD = 57108, //Reduces damage by 95% for 5s
+    SPELL_DRAGON_ENGULF = 74562,
+    SPELL_DRAGON_BREATH = 74525,
+    SPELL_DRAGON_TAIL_WHIP = 74531,
+    SPELL_DRAGON_BERSERK = 26662,
+    SPELL_DRAGON_CLAW = 74524,
+    SPELL_DRAGON_MASSIVE_FLAMESTRIKE = 26558,
+    //SPELL_DRAGON_FIREBALL_BARRAGE = 37541,
+    /* Others */
+    SPELL_TELEPORT_VISUAL = 64446,
+    /* Disable Class Spells */
+    SPELL_VANISH_1 = 1856,
+    SPELL_VANISH_2 = 1857,
+    SPELL_VANISH_3 = 26889,
+};
+
+enum SpawnIds
+{
+    /* First Wave */
+    NPC_RED_BLOOD_GUARD =         88001,
+    NPC_RED_BLOOD_GUARD_MINI =    88002,
+    NPC_RED_BLOOD_GUARD_MINI2 =   88003,
+    NPC_RED_BLOOD_GUARD_MINI3 =   88004,
+    /* First Wave Treat */
+    NPC_WAVE_SPAWN_TRIGGER =      88500,
+    NPC_GARM_WATCHER       =      80050,
+    NPC_FRIGID_PROTO_DRAKE =      80051,
+    NPC_OSTERKILGR         =      80052,
+    NPC_BLIGHT_FALCONER    =      80053,
+    NPC_CONVERTED_HERO     =      80054,
+    NPC_PORTAL =                  88501,
+    /* First Wave Elite */                     /* NPC : Display ID */
+    NPC_HANK_THE_TANK  =          88011,    // Tank: 27930 Paladin Tank BE
+    NPC_FIELD_MEDIC  =              88012,    // Healer: 17544 Spore thing
+    /* Second Wave */
+    NPC_ROGUE_INITIATE =           88013, // Main rogue: 24918
+    NPC_ROGUE_INITIATE_1 =          88014, // Sidekick(easier to kill): 24919
+    NPC_ROGUE_INITIATE_2 =           88015, // Sidekick(easier to kill): 24919
+    /* Second Wave Treat */
+    NPC_THE_UNHOLY =               88016, // Main: 25446
+    NPC_THE_UNHOLY_TWIN =           88017, // Twin: 25496
+    NPC_THE_UNHOLY_PET =           88018, // Their Pet: 25467 (no spells, normal attacks just to occupy the player) Maybe just SPELL_PET_BITE ?
+    /* Second Wave Elite */
+    NPC_RIDERS_OFTHE_ICE =           88019, // Main/Healer: 25083
+    NPC_RIDERS_OFTHE_ICE_1 =      88020, // Brute: 25082
+    NPC_RIDERS_OFTHE_ICE_2 =       88021, // Brute: 25082
+    /* Final Wave Boss */
+    NPC_DRAGON_BOSS =               88022, // Dragon: 25015
+    NPC_DRAGON_BOSS_TRIGGER =     88023,
+    GOBJECT_DRAGON_BOSS_RUNE =    183036,
+};
+
+enum eEnums
+{
+    ITEM_INTRAVENOUS_HEALING_POTION = 44698, // You can change the items they can heal with here
+    DIRE_MAUL_ZONE = 2557,
+    DIRE_MAUL_AREA = 357, //3217,
+    PVP_END_TOKEN = 47241, // You can easily change this
+    SOUND_HORN_WAVE_START = 7054,
+    SOUND_WAVE_COMPLETE = 8571,
+};
+
+struct DragonMove
+{
+    uint32 gobject;
+    uint32 spellId;
+    float x, y, z, o;
+};
+
+uint32 spellDisables[] = { SPELL_VANISH_1, SPELL_VANISH_2, SPELL_VANISH_3 };
+
+static Position sTeleOut[] =
+{
+    { -4286.56f, 1330.970f, 161.21f, 0.019994f }
+};
+
+static DragonMove sMoveData[] =
+{
+    {GOBJECT_DRAGON_BOSS_RUNE, SPELL_DRAGON_MASSIVE_FLAMESTRIKE, -3786.241943f, 1096.538452f, 153.903366f, 6.257603f }
+};
+
+#define MAX_WAVE_SPAWN_LOCATIONS 20
+const uint32 waveList[MAX_WAVE_SPAWN_LOCATIONS] =
+{
+       /* First Wave Ids */
+       NPC_RED_BLOOD_GUARD,
+       /* First Wave Treat Ids */
+       NPC_WAVE_SPAWN_TRIGGER, NPC_GARM_WATCHER, NPC_FRIGID_PROTO_DRAKE, NPC_OSTERKILGR, NPC_BLIGHT_FALCONER, NPC_CONVERTED_HERO, NPC_PORTAL,
+       /* First Wave Elite Ids */
+       NPC_HANK_THE_TANK, NPC_FIELD_MEDIC,
+       /* Second Wave Ids */
+       NPC_ROGUE_INITIATE, NPC_ROGUE_INITIATE_1, NPC_ROGUE_INITIATE_2,
+       /* Second Wave Treat Ids */
+       NPC_THE_UNHOLY, NPC_THE_UNHOLY_TWIN, NPC_THE_UNHOLY_PET,
+       /* Second Wave Elite Ids */
+       NPC_RIDERS_OFTHE_ICE, NPC_RIDERS_OFTHE_ICE_1, NPC_RIDERS_OFTHE_ICE_2,
+       /* Final Wave Boss */
+       NPC_DRAGON_BOSS,
+};
+
+static Position m_WaveSpawns[] =
+{
+    /*    X               Y            Z           O      */
+                 /* All Waves Spawns */
+    { -3756.859863f, 1097.575317f, 131.969559f, 6.159780f },
+                 /* First Wave Treat */
+    { -3760.98f, 1082.98f, 131.96f, 0.214342f }, // Portal 1 Location
+    { -3751.31f, 1106.84f, 131.96f, 5.364266f }  // Portal 2 Location
+};
+
+void MessageOnWave(Creature * me, uint32 eventId)
+{
+    stringstream ss;
+    switch(eventId)
+    {
+       case EVENT_CHECK_ACTIVITY: // Before Wave 1 starts
+           ss << playerName.c_str()
+              << " get ready! Next wave begins in 10 seconds!";
+           break;
+
+       case EVENT_CHECK_WAVES:
+           {
+               if( isWaveBossDead == 1)
+               {
+                   ss << "I can't believe it! "
+                      << playerName.c_str()
+                      << " has killed the Red Blood Guard! We will see next wave, which is in 25 seconds, gear up!";
+               }
+               else if (isWaveBossDead == 2)
+               {
+                   ss << "This is unreal! "
+                      << playerName.c_str()
+                      << " has dominated the treat wave! Next wave is in 35 seconds! Get ready for a good experience.";
+               }
+               else if (isWaveBossDead == 3)
+               {
+                   ss << "Holy shit! "
+                      << playerName.c_str()
+                      << " has demolished the elite! Good luck getting through the others... Second wave begins in 25 seconds! You may want to heal...";
+               }
+               else if (isWaveBossDead == 4)
+               {
+                   ss << "Excellent! "
+                      << playerName.c_str()
+                      << " has stricken down the rogues! Well done! Next wave is in 35 seconds, be prepared!";
+               }
+               else if (isWaveBossDead == 5)
+               {
+                   ss << "Zing! I can't believe what I'm seeing! "
+                      << playerName.c_str()
+                      << " has defeated the Unholy Twins, EPIC WIN! Next wave in 40 seconds, get ready!";
+               }
+               else if (isWaveBossDead == 6)
+               {
+                   ss << "WOW! No Way! "
+                      << playerName.c_str()
+                      << " has stopped the riders dead in their tracks. Great job! Final wave beings in 35 seconds, get buffed up!";
+               }
+               else if (isWaveBossDead == 7)
+               {
+                   ss << "Just...a moment of silence. "
+                      << playerName.c_str()
+                      << " has just won this entire challenge! Congratulations!";
+               }
+           }break;
+
+       case EVENT_FIRST_WAVE:
+           ss << "First wave has begun!"
+              << " From the blood gates of hell, here is,"
+              << " Arena Master, Red Blood Guard!";
+           break;
+
+       case EVENT_FIRST_WAVE_TREAT:
+           ss << "First treat wave has begun!"
+              << " Bounding across the continent, you will face many challenges!";
+           break;
+
+       case EVENT_FIRST_WAVE_ELITE:
+           ss << "First elite wave has begun!"
+              << " Say your last words, this elite team wont give you another chance to."
+              << " Entering the arena, Hank the Tank and his heal happy spore companion. Prepare for the worst!";
+           break;
+
+       case EVENT_SECOND_WAVE:
+           ss << "Second wave has begun!"
+              << " Trust your eyes and dont blink, this team of initiates only provide pain!"
+              << " The quick, the stealthy.. The Rogue Initiates, maybe run?";
+           break;
+
+       case EVENT_SECOND_WAVE_TREAT:
+          ss << "Second treat wave has begun!"
+             << " From the depths of the underworld, they were sent back here to take care of business!"
+             << " The deadliest duo, the Unholy Twins - Seal your fate, destroy them!";
+           break;
+
+       case EVENT_SECOND_WAVE_ELITE:
+          ss << "Second elite wave has begun!"
+             << " The Riders of the Ice have entered the arena!"
+             << " Don't be fooled by their size, they will walk all over you. Attack!";
+           break;
+
+       case EVENT_FINAL_WAVE_BOSS:
+          ss << "From deep into the Earth's core "
+             << " there lies a entirely different aspect of a challenge. "
+             << " Get Ready! Arena Dragon is here!";
+           break;
+    }
+    me->Yell(ss.str().c_str(), LANG_UNIVERSAL, 0);
+}
+
+void DoSendCompleteMessage(string who)
+{
+    stringstream ss;
+    ss << who.c_str()
+        << "has completed the Dire Maul Arena Event!"
+        << "The event is now opened and ready for another victim!";
+    sWorld->SendGlobalText(ss.str().c_str(), nullptr);
+}
+
+void AddEndRewards(ChatHandler* handler, Player * player, uint32 honoramount, uint32 tokenId, uint32 tokenAmount)
+{
+    //uint32 curHonor = player->GetHonorPoints();
+    player->RewardHonor(player, honoramount, -1, true);
+    handler->PSendSysMessage("Added %u honor!", honoramount);
+    player->AddItem(tokenId, tokenAmount);
+}
+/* End Battle Functions */
+void DoEndBattle(Creature * me)
+{
+    isBattleActive = false;
+    //m_PlayerGUID = 0;
+    playerName = "";
+    me->DespawnOrUnsummon(1);
+}
+
+void DoEndBattle(Creature * me, SummonList summons)
+{
+    isBattleActive = false;
+    //m_PlayerGUID = 0;
+    playerName = "";
+    summons.DespawnAll();
+    me->DespawnOrUnsummon(1);
+}
+/* Increase Health Function ~ Boss Fight Pet */
+void DoIncreaseHealth(Creature * me, float size, uint32 phase, uint32 phaseAmount)
+{
+    me->SetMaxHealth(me->GetMaxHealth()+40000);
+    me->SetHealth(me->GetMaxHealth()+40000);
+    me->SetFloatValue(OBJECT_FIELD_SCALE_X, size);
+    phase = phaseAmount;
+}
-- 
2.8.4

